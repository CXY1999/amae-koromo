{"version":3,"sources":["../node_modules/clsx/dist/clsx.m.js","../node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js","../node_modules/@babel/runtime/helpers/interopRequireDefault.js","../node_modules/babel-runtime/core-js/object/keys.js","../node_modules/core-js/library/fn/object/keys.js","../node_modules/core-js/library/modules/es6.object.keys.js","../node_modules/babel-runtime/helpers/objectWithoutProperties.js","../node_modules/linear-layout-vector/index.js","../node_modules/dom-helpers/util/scrollbarSize.js","../node_modules/dom-helpers/util/inDOM.js","../node_modules/react-virtualized/dist/es/Table/defaultHeaderRowRenderer.js","../node_modules/react-virtualized/dist/es/Table/SortDirection.js","../node_modules/react-virtualized/dist/es/Table/SortIndicator.js","../node_modules/react-virtualized/dist/es/Table/defaultHeaderRenderer.js","../node_modules/react-virtualized/dist/es/Table/defaultRowRenderer.js","../node_modules/react-virtualized/dist/es/Table/Column.js","../node_modules/react-virtualized/dist/es/Table/defaultCellDataGetter.js","../node_modules/react-virtualized/dist/es/Table/defaultCellRenderer.js","../node_modules/react-virtualized/dist/es/Grid/utils/calculateSizeAndPositionDataAndUpdateScrollOffset.js","../node_modules/react-virtualized/dist/es/Grid/utils/CellSizeAndPositionManager.js","../node_modules/react-virtualized/dist/es/Grid/utils/maxElementSize.js","../node_modules/react-virtualized/dist/es/Grid/utils/ScalingCellSizeAndPositionManager.js","../node_modules/react-virtualized/dist/es/utils/createCallbackMemoizer.js","../node_modules/react-virtualized/dist/es/Grid/defaultOverscanIndicesGetter.js","../node_modules/react-virtualized/dist/es/Grid/utils/updateScrollIndexHelper.js","../node_modules/react-virtualized/dist/es/Grid/Grid.js","../node_modules/react-virtualized/dist/es/Grid/defaultCellRangeRenderer.js","../node_modules/react-virtualized/dist/es/Grid/accessibilityOverscanIndicesGetter.js","../node_modules/react-virtualized/dist/es/Table/Table.js","../node_modules/react-virtualized/dist/es/Table/index.js","../node_modules/react-virtualized/dist/es/AutoSizer/AutoSizer.js","../node_modules/react-virtualized/dist/es/AutoSizer/index.js"],"names":["toVal","mix","k","y","str","push","length","call","x","i","arguments","componentWillMount","state","this","constructor","getDerivedStateFromProps","props","undefined","setState","componentWillReceiveProps","nextProps","prevState","bind","componentWillUpdate","nextState","prevProps","__reactInternalSnapshotFlag","__reactInternalSnapshot","getSnapshotBeforeUpdate","polyfill","Component","prototype","isReactComponent","Error","foundWillMountName","foundWillReceivePropsName","foundWillUpdateName","UNSAFE_componentWillMount","UNSAFE_componentWillReceiveProps","UNSAFE_componentWillUpdate","componentName","displayName","name","newApiName","componentDidUpdate","maybeSnapshot","snapshot","__suppressDeprecationWarning","module","exports","obj","__esModule","default","Object","keys","toObject","$keys","it","target","indexOf","hasOwnProperty","LinearLayoutVector","block_size","pow","Math","log","size","mask","block_shift","block_mask","block_table","_defaultSize","_axisOffset","_gap","removes","inserts","_length","_pendingLength","isIntervalClear","block","index","count","sizes","inBlockCopy","dstBlock","dstIndexStart","srcBlock","srcIndexStart","ascending","srcIndex","dstIndex","increment","dstSizes","srcSizes","dstValue","NaN","srcValue","sizesSumDelta","defaultCountDelta","sizesSum","defaultCount","copyInterval","dstBlockIndex","dstSizesIndex","srcBlockIndex","srcSizesIndex","copyCount","min","dstStartIndex","srcStartIndex","Block","clearInterval","start","end","blockIndex","sizesIndex","clearCount","removeIntervals","intervals","intervalsCount","reverse","getLength","srcStart","dstStart","intervalEnd","nextIntervalStart","setLength","insertIntervals","newLength","oldLength","srcEnd","dstEnd","intervalStart","flushPendingChanges","indexOfInternal","distance","curDistance","getAxisOffset","blockSize","defaultSize","gap","getGap","blockGap","blockTable","blockTableLength","blockDistance","n","floor","Number","Array","endIndex","partialBlock","getDefaultSize","setDefaultSize","value","setAxisOffset","setGap","getItemSize","setItemSize","oldValue","insert","lastIndex","max","remove","lastBlock","lastBlockOffset","lastBlockLength","clear","toString","_interopRequireDefault","recalc","_inDOM","scrollDiv","document","createElement","style","position","top","width","height","overflow","body","appendChild","offsetWidth","clientWidth","removeChild","_default","window","defaultHeaderRowRenderer","_ref","className","columns","role","propTypes","ASC","DESC","SortIndicator","sortDirection","classNames","viewBox","d","fill","defaultHeaderRenderer","dataKey","label","sortBy","showSortIndicator","children","key","title","defaultRowRenderer","onRowClick","onRowDoubleClick","onRowMouseOut","onRowMouseOver","onRowRightClick","rowData","a11yProps","tabIndex","onClick","event","onDoubleClick","onMouseOut","onMouseOver","onContextMenu","_React$Component","Column","__proto__","apply","defaultProps","cellDataGetter","get","cellRenderer","cellData","String","defaultSortDirection","flexGrow","flexShrink","headerRenderer","calculateSizeAndPositionDataAndUpdateScrollOffset","cellCount","cellSize","computeMetadataCallback","computeMetadataCallbackProps","nextCellsCount","nextCellSize","nextScrollToIndex","scrollToIndex","updateScrollOffsetForScrollToIndex","CellSizeAndPositionManager","cellSizeGetter","estimatedCellSize","_lastMeasuredIndex","_cellSizeGetter","_cellCount","_estimatedCellSize","_layoutVector","_ref2","vector","token","_size","offset","_ref3","_ref3$align","align","containerSize","currentOffset","targetIndex","datum","getSizeAndPositionOfCell","maxOffset","minOffset","idealOffset","totalSize","getTotalSize","params","_findNearestCell","stop","isNaN","targetOffset","nearestCellIndex","getMaxElementSize","chrome","webstore","ScalingCellSizeAndPositionManager","_ref$maxScrollSize","maxScrollSize","_cellSizeAndPositionManager","_maxScrollSize","configure","getCellCount","getEstimatedCellSize","getLastMeasuredIndex","safeTotalSize","offsetPercentage","_getOffsetPercentage","round","getSizeAndPositionOfLastMeasuredCell","_safeOffsetToOffset","getUpdatedOffsetForIndex","_offsetToSafeOffset","_ref4","getVisibleCellRange","resetCell","_ref5","_ref6","_ref7","createCallbackMemoizer","requireAllKeys","cachedIndices","callback","indices","allInitialized","every","isArray","indexChanged","some","cachedValue","join","SCROLL_DIRECTION_FORWARD","updateScrollIndexHelper","cellSizeAndPositionManager","previousCellsCount","previousCellSize","previousScrollToAlignment","previousScrollToIndex","previousSize","scrollOffset","scrollToAlignment","sizeJustIncreasedFromZero","updateScrollIndexCallback","hasScrollToIndex","SCROLL_POSITION_CHANGE_REASONS","_React$PureComponent","Grid","_this","_onGridRenderedMemoizer","_onScrollMemoizer","_deferredInvalidateColumnIndex","_deferredInvalidateRowIndex","_recomputeScrollLeftFlag","_recomputeScrollTopFlag","_horizontalScrollBarSize","_verticalScrollBarSize","_scrollbarPresenceChanged","_renderedColumnStartIndex","_renderedColumnStopIndex","_renderedRowStartIndex","_renderedRowStopIndex","_styleCache","_cellCache","_debounceScrollEndedCallback","_disablePointerEventsTimeoutId","isScrolling","needToResetStyleCache","_invokeOnGridRenderedHelper","onSectionRendered","columnOverscanStartIndex","_columnStartIndex","columnOverscanStopIndex","_columnStopIndex","columnStartIndex","columnStopIndex","rowOverscanStartIndex","_rowStartIndex","rowOverscanStopIndex","_rowStopIndex","rowStartIndex","rowStopIndex","_setScrollingContainerRef","ref","_scrollingContainer","_onScroll","handleScrollEvent","columnSizeAndPositionManager","columnCount","_wrapSizeGetter","columnWidth","_getEstimatedColumnSize","rowSizeAndPositionManager","rowCount","rowHeight","_getEstimatedRowSize","instanceProps","prevColumnWidth","prevRowHeight","prevColumnCount","prevRowCount","prevIsScrolling","prevScrollToColumn","scrollToColumn","prevScrollToRow","scrollToRow","prevScrollLeft","scrollLeft","prevScrollTop","scrollTop","scrollbarSize","scrollbarSizeMeasured","scrollDirectionHorizontal","scrollDirectionVertical","scrollPositionChangeReason","_initialScrollTop","_getCalculatedScrollTop","_initialScrollLeft","_getCalculatedScrollLeft","_ref$alignment","alignment","_ref$columnIndex","columnIndex","_ref$rowIndex","rowIndex","offsetProps","_ref2$scrollLeft","scrollLeftParam","_ref2$scrollTop","scrollTopParam","_debounceScrollEnded","_props","autoHeight","autoWidth","totalRowsHeight","totalColumnsWidth","newState","_invokeOnScrollMemoizer","_props2","_ref4$columnIndex","_ref4$rowIndex","_props3","forceUpdate","_updateScrollLeftForScrollToColumn","_updateScrollTopForScrollToRow","_props4","getScrollbarSize","_handleInvalidatedGridSize","stateUpdate","_getScrollToPositionStateUpdate","sizeIsBiggerThanZero","_maybeCallOnScrollbarPresenceChange","_this2","_props5","_state","columnOrRowCountJustIncreasedFromZero","_props6","autoContainerWidth","containerProps","containerRole","containerStyle","id","noContentRenderer","_state2","_isScrolling","gridStyle","boxSizing","direction","WebkitOverflowScrolling","willChange","_resetStyleCache","_calculateChildrenToRender","verticalScrollBarSize","horizontalScrollBarSize","overflowX","overflowY","childrenToDisplay","_childrenToDisplay","showNoContentRenderer","onScroll","maxWidth","maxHeight","pointerEvents","cellRangeRenderer","deferredMeasurementCache","overscanColumnCount","overscanIndicesGetter","overscanRowCount","isScrollingOptOut","visibleColumnIndices","visibleRowIndices","horizontalOffsetAdjustment","getOffsetAdjustment","verticalOffsetAdjustment","overscanColumnIndices","overscanCellsCount","scrollDirection","startIndex","stopIndex","overscanRowIndices","overscanStartIndex","overscanStopIndex","hasFixedHeight","has","hasFixedWidth","cellCache","parent","styleCache","scrollingResetTimeInterval","requestAnimationTimeout","recomputeGridSize","_this3","_props7","clientHeight","scrollHeight","scrollWidth","Boolean","_onScrollbarPresenceChange","onScrollbarPresenceChange","horizontal","vertical","_ref8","_getScrollLeftForScrollToColumnStateUpdate","_getScrollTopForScrollToRowStateUpdate","maybeStateA","maybeStateB","estimatedColumnSize","estimatedRowSize","_ref9","finalColumn","scrollBarSize","calculatedScrollLeft","finalRow","calculatedScrollTop","renderedCells","areOffsetsAdjusted","canCacheStyle","rowDatum","columnDatum","isVisible","left","cellRendererParams","renderedCell","Table","scrollbarWidth","_createColumn","_createRow","_onSectionRendered","_setRef","getOffsetForCell","invalidateCellSizeAfterRender","measureAllCells","_ref3$columnIndex","_ref3$rowIndex","scrollToPosition","scrollToCell","_setScrollbarWidth","disableHeader","gridClassName","headerHeight","headerRowRenderer","noRowsRenderer","rowClassName","rowStyle","availableRowsHeight","rowClass","rowStyleObject","_cachedColumnStyles","toArray","forEach","column","flexStyles","_getFlexStyleForColumn","_getHeaderColumns","paddingRight","onColumnClick","_column$props","columnData","headerClassName","headerStyle","onHeaderClick","sort","_column$props2","disableSort","sortEnabled","ReactVirtualized__Table__sortableHeaderColumn","renderedHeader","headerOnClick","headerOnKeyDown","headerTabIndex","headerAriaSort","headerAriaLabel","newSortDirection","onKeyDown","rowGetter","rowRenderer","map","flattenedStyle","_getRowHeight","customStyle","flexValue","flex","msFlex","WebkitFlex","minWidth","_this4","_createHeader","onRowsRendered","_Grid","AutoSizer","_temp","_ret","_len","args","_key","concat","defaultHeight","defaultWidth","_onResize","_this$props","disableHeight","disableWidth","onResize","_parentNode","_height","offsetHeight","_width","_style","getComputedStyle","paddingLeft","parseInt","paddingTop","paddingBottom","newHeight","newWidth","autoSizer","_autoSizer","nonce","parentNode","ownerDocument","defaultView","HTMLElement","_detectElementResize","addResizeListener","removeResizeListener","outerStyle","childParams"],"mappings":"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","file":"static/js/6.c89c1caf.chunk.js","sourcesContent":["function toVal(mix) {\n  var k,\n      y,\n      str = '';\n\n  if (mix) {\n    if (typeof mix === 'object') {\n      if (!!mix.push) {\n        for (k = 0; k < mix.length; k++) {\n          if (mix[k] && (y = toVal(mix[k]))) {\n            str && (str += ' ');\n            str += y;\n          }\n        }\n      } else {\n        for (k in mix) {\n          if (mix[k] && (y = toVal(k))) {\n            str && (str += ' ');\n            str += y;\n          }\n        }\n      }\n    } else if (typeof mix !== 'boolean' && !mix.call) {\n      str && (str += ' ');\n      str += mix;\n    }\n  }\n\n  return str;\n}\n\nexport default function () {\n  var i = 0,\n      x,\n      str = '';\n\n  while (i < arguments.length) {\n    if (x = toVal(arguments[i++])) {\n      str && (str += ' ');\n      str += x;\n    }\n  }\n\n  return str;\n}","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nfunction componentWillMount() {\n  // Call this.constructor.gDSFP to support sub-classes.\n  var state = this.constructor.getDerivedStateFromProps(this.props, this.state);\n\n  if (state !== null && state !== undefined) {\n    this.setState(state);\n  }\n}\n\nfunction componentWillReceiveProps(nextProps) {\n  // Call this.constructor.gDSFP to support sub-classes.\n  // Use the setState() updater to ensure state isn't stale in certain edge cases.\n  function updater(prevState) {\n    var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);\n    return state !== null && state !== undefined ? state : null;\n  } // Binding \"this\" is important for shallow renderer support.\n\n\n  this.setState(updater.bind(this));\n}\n\nfunction componentWillUpdate(nextProps, nextState) {\n  try {\n    var prevProps = this.props;\n    var prevState = this.state;\n    this.props = nextProps;\n    this.state = nextState;\n    this.__reactInternalSnapshotFlag = true;\n    this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(prevProps, prevState);\n  } finally {\n    this.props = prevProps;\n    this.state = prevState;\n  }\n} // React may warn about cWM/cWRP/cWU methods being deprecated.\n// Add a flag to suppress these warnings for this special case.\n\n\ncomponentWillMount.__suppressDeprecationWarning = true;\ncomponentWillReceiveProps.__suppressDeprecationWarning = true;\ncomponentWillUpdate.__suppressDeprecationWarning = true;\n\nfunction polyfill(Component) {\n  var prototype = Component.prototype;\n\n  if (!prototype || !prototype.isReactComponent) {\n    throw new Error('Can only polyfill class components');\n  }\n\n  if (typeof Component.getDerivedStateFromProps !== 'function' && typeof prototype.getSnapshotBeforeUpdate !== 'function') {\n    return Component;\n  } // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n  // Error if any of these lifecycles are present,\n  // Because they would work differently between older and newer (16.3+) versions of React.\n\n\n  var foundWillMountName = null;\n  var foundWillReceivePropsName = null;\n  var foundWillUpdateName = null;\n\n  if (typeof prototype.componentWillMount === 'function') {\n    foundWillMountName = 'componentWillMount';\n  } else if (typeof prototype.UNSAFE_componentWillMount === 'function') {\n    foundWillMountName = 'UNSAFE_componentWillMount';\n  }\n\n  if (typeof prototype.componentWillReceiveProps === 'function') {\n    foundWillReceivePropsName = 'componentWillReceiveProps';\n  } else if (typeof prototype.UNSAFE_componentWillReceiveProps === 'function') {\n    foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n  }\n\n  if (typeof prototype.componentWillUpdate === 'function') {\n    foundWillUpdateName = 'componentWillUpdate';\n  } else if (typeof prototype.UNSAFE_componentWillUpdate === 'function') {\n    foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n  }\n\n  if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n    var componentName = Component.displayName || Component.name;\n    var newApiName = typeof Component.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';\n    throw Error('Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' + componentName + ' uses ' + newApiName + ' but also contains the following legacy lifecycles:' + (foundWillMountName !== null ? '\\n  ' + foundWillMountName : '') + (foundWillReceivePropsName !== null ? '\\n  ' + foundWillReceivePropsName : '') + (foundWillUpdateName !== null ? '\\n  ' + foundWillUpdateName : '') + '\\n\\nThe above lifecycles should be removed. Learn more about this warning here:\\n' + 'https://fb.me/react-async-component-lifecycle-hooks');\n  } // React <= 16.2 does not support static getDerivedStateFromProps.\n  // As a workaround, use cWM and cWRP to invoke the new static lifecycle.\n  // Newer versions of React will ignore these lifecycles if gDSFP exists.\n\n\n  if (typeof Component.getDerivedStateFromProps === 'function') {\n    prototype.componentWillMount = componentWillMount;\n    prototype.componentWillReceiveProps = componentWillReceiveProps;\n  } // React <= 16.2 does not support getSnapshotBeforeUpdate.\n  // As a workaround, use cWU to invoke the new lifecycle.\n  // Newer versions of React will ignore that lifecycle if gSBU exists.\n\n\n  if (typeof prototype.getSnapshotBeforeUpdate === 'function') {\n    if (typeof prototype.componentDidUpdate !== 'function') {\n      throw new Error('Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype');\n    }\n\n    prototype.componentWillUpdate = componentWillUpdate;\n    var componentDidUpdate = prototype.componentDidUpdate;\n\n    prototype.componentDidUpdate = function componentDidUpdatePolyfill(prevProps, prevState, maybeSnapshot) {\n      // 16.3+ will not execute our will-update method;\n      // It will pass a snapshot value to did-update though.\n      // Older versions will require our polyfilled will-update value.\n      // We need to handle both cases, but can't just check for the presence of \"maybeSnapshot\",\n      // Because for <= 15.x versions this might be a \"prevContext\" object.\n      // We also can't just check \"__reactInternalSnapshot\",\n      // Because get-snapshot might return a falsy value.\n      // So check for the explicit __reactInternalSnapshotFlag flag to determine behavior.\n      var snapshot = this.__reactInternalSnapshotFlag ? this.__reactInternalSnapshot : maybeSnapshot;\n      componentDidUpdate.call(this, prevProps, prevState, snapshot);\n    };\n  }\n\n  return Component;\n}\n\nexport { polyfill };","function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nmodule.exports = _interopRequireDefault;","module.exports = {\n  \"default\": require(\"core-js/library/fn/object/keys\"),\n  __esModule: true\n};","require('../../modules/es6.object.keys');\n\nmodule.exports = require('../../modules/_core').Object.keys;","// 19.1.2.14 Object.keys(O)\nvar toObject = require('./_to-object');\n\nvar $keys = require('./_object-keys');\n\nrequire('./_object-sap')('keys', function () {\n  return function keys(it) {\n    return $keys(toObject(it));\n  };\n});","\"use strict\";\n\nexports.__esModule = true;\n\nexports.default = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};","module.exports = LinearLayoutVector;\nLinearLayoutVector.prototype.getLength = getLength;\nLinearLayoutVector.prototype.setLength = setLength;\nLinearLayoutVector.prototype.getDefaultSize = getDefaultSize;\nLinearLayoutVector.prototype.setDefaultSize = setDefaultSize;\nLinearLayoutVector.prototype.getAxisOffset = getAxisOffset;\nLinearLayoutVector.prototype.setAxisOffset = setAxisOffset;\nLinearLayoutVector.prototype.getGap = getGap;\nLinearLayoutVector.prototype.setGap = setGap;\nLinearLayoutVector.prototype.getItemSize = getItemSize;\nLinearLayoutVector.prototype.setItemSize = setItemSize;\nLinearLayoutVector.prototype.insert = insert;\nLinearLayoutVector.prototype.remove = remove;\nLinearLayoutVector.prototype.start = start;\nLinearLayoutVector.prototype.end = end;\nLinearLayoutVector.prototype.indexOf = indexOf;\nLinearLayoutVector.prototype.clear = clear;\nLinearLayoutVector.prototype.toString = toString;\n/**\n * A sparse array of sizes that represent items in a dimension.\n *\n * Provides efficient support for finding the cumulative distance to\n * the start/end of an item along the axis, and similarly for finding the\n * index of the item at a particular distance.\n *\n * Default size is used for items whose size hasn't been specified.\n */\n\nfunction LinearLayoutVector(block_size) {\n  if (block_size === undefined) {\n    block_size = 128;\n  } // Assumption: vector elements (sizes) will typically be set in\n  // small ranges that reflect localized scrolling.  Allocate vector\n  // elements in blocks of block_size, which must be a power of 2.\n  // block_shift is the power of 2 and block_mask masks off as many\n  // low order bits.  The block_table contains all of the allocated\n  // blocks and has length/block_size elements which are allocated lazily.\n\n\n  var pow = Math.log(block_size) / Math.log(2) | 0,\n      size = Math.pow(2, pow),\n      mask = size - 1;\n  this.block_size = size;\n  this.block_shift = pow;\n  this.block_mask = mask;\n  this.block_table = [];\n  this._defaultSize = 0;\n  this._axisOffset = 0;\n  this._gap = 0; // Sorted Vector of intervals for the pending removes, in descending order,\n  // for example [7, 5, 3, 1] for the removes at 7, 6, 5, 3, 2, 1\n\n  this.removes = null; // Sorted Vector of intervals for the pending inserts, in ascending order,\n  // for example [1, 3, 5, 7] for the inserts at 1, 2, 3, 5, 6, 7\n\n  this.inserts = null;\n  this._length = 0; // What the length will be after any pending changes are flushed.\n\n  this._pendingLength = -1;\n}\n/**\n * The number of item size valued elements.\n *\n * @default 0\n */\n\n\nfunction getLength() {\n  return this._pendingLength === -1 ? this._length : this._pendingLength;\n}\n/**\n * @private\n * Grows or truncates the vector to be the specified newLength.\n * When truncating, releases empty blocks and sets to NaN any values\n * in the last block beyond the newLength.\n */\n\n\nfunction setLength(newLength) {\n  flushPendingChanges.call(this);\n\n  if (newLength < this._length) {\n    // Clear any remaining non-NaN values in the last block\n    var blockIndex = newLength >> this.block_shift;\n    var endIndex = Math.min(blockIndex * this.block_size + this.block_size, this._length) - 1;\n    clearInterval.call(this, newLength, endIndex);\n  }\n\n  this._length = newLength; // update the table\n\n  var partialBlock = (this._length & this.block_mask) === 0 ? 0 : 1;\n  this.block_table.length = (this._length >> this.block_shift) + partialBlock;\n} //----------------------------------\n//  defaultSize\n//----------------------------------\n\n/**\n * The size of items whose size was not specified with setItemSize.\n *\n * @default 0\n */\n\n\nfunction getDefaultSize() {\n  return this._defaultSize;\n}\n/**\n * @private\n */\n\n\nfunction setDefaultSize(value) {\n  this._defaultSize = value;\n} //----------------------------------\n//  axisOffset\n//----------------------------------\n\n/**\n * The offset of the first item from the origin in the majorAxis\n * direction. This is useful when implementing padding,\n * in addition to gaps, for virtual layouts.\n *\n * @see #gap\n */\n\n\nfunction getAxisOffset() {\n  return this._axisOffset;\n}\n/**\n * @private\n */\n\n\nfunction setAxisOffset(value) {\n  this._axisOffset = value;\n} //----------------------------------\n//  gap\n//----------------------------------\n\n/**\n * The distance between items.\n *\n * @default 0\n */\n\n\nfunction getGap() {\n  return this._gap;\n}\n/**\n * @private\n */\n\n\nfunction setGap(value) {\n  this._gap = value;\n} //--------------------------------------------------------------------------\n//\n//  Methods\n//\n//--------------------------------------------------------------------------\n\n/**\n * Return the size of the item at index.  If no size was ever\n * specified then then the defaultSize is returned.\n *\n * @param index The item's index.\n * @see defaultSize\n */\n\n\nfunction getItemSize(index) {\n  flushPendingChanges.call(this);\n  var block = this.block_table[index >> this.block_shift];\n\n  if (block) {\n    var value = block.sizes[index & this.block_mask];\n    return value !== value ? this._defaultSize : value;\n  } else {\n    return this._defaultSize;\n  }\n}\n/**\n * Set the size of the item at index. If an index is\n * set to <code>NaN</code> then subsequent calls to get\n * will return the defaultSize.\n *\n * @param index The item's index.\n * @param value The item's size.\n * @see defaultSize\n */\n\n\nfunction setItemSize(index, value) {\n  flushPendingChanges.call(this);\n\n  if (index >= this.getLength()) {\n    throw new Error(\"Invalid index and all that.\");\n  }\n\n  var blockIndex = index >> this.block_shift;\n  var block = this.block_table[blockIndex];\n\n  if (!block) {\n    block = this.block_table[blockIndex] = new Block(this.block_size);\n  }\n\n  var sizesIndex = index & this.block_mask;\n  var sizes = block.sizes;\n  var oldValue = sizes[sizesIndex];\n\n  if (oldValue === value) {\n    return;\n  }\n\n  if (oldValue !== oldValue) {\n    block.defaultCount -= 1;\n    block.sizesSum += value;\n  } else if (value !== value) {\n    block.defaultCount += 1;\n    block.sizesSum -= oldValue;\n  } else {\n    block.sizesSum += value - oldValue;\n  }\n\n  sizes[sizesIndex] = value;\n}\n/**\n * Make room for a new item at index by shifting all of the sizes\n * one position to the right, beginning with startIndex.\n *\n * The value at index will be NaN.\n *\n * This is similar to array.splice(index, 0, NaN).\n *\n * @param index The position of the new NaN size item.\n */\n\n\nfunction insert(index) {\n  // We don't support interleaved pending inserts and removes\n  if (this.removes) {\n    flushPendingChanges.call(this);\n  }\n\n  if (this.inserts) {\n    // Update the last interval or add a new one?\n    var lastIndex = this.inserts.length - 1;\n    var intervalEnd = this.inserts[lastIndex];\n\n    if (index === intervalEnd + 1) {\n      // Extend the end of the interval\n      this.inserts[lastIndex] = index;\n    } else if (index > intervalEnd) {\n      // New interval\n      this.inserts.push(index);\n      this.inserts.push(index);\n    } else {\n      // We can't support pending inserts that are not ascending\n      flushPendingChanges.call(this);\n    }\n  }\n\n  this._pendingLength = Math.max(this._length, index + 1);\n\n  if (!this.inserts) {\n    this.inserts = [];\n    this.inserts.push(index);\n    this.inserts.push(index);\n  }\n}\n/**\n * Remove index by shifting all of the sizes one position to the left,\n * begining with index+1.\n *\n * This is similar to array.splice(index, 1).\n *\n * @param index The position to be removed.\n */\n\n\nfunction remove(index) {\n  // We don't support interleaved pending inserts and removes\n  if (this.inserts) {\n    flushPendingChanges.call(this);\n  } // length getter takes into account pending inserts/removes but doesn't flush\n\n\n  if (index >= this.getLength()) {\n    throw new Error(\"Invalid index and all that.\");\n  }\n\n  if (this.removes) {\n    // Update the last interval or add a new one?\n    var lastIndex = this.removes.length - 1;\n    var intervalStart = this.removes[lastIndex];\n\n    if (index === intervalStart - 1) {\n      // Extend the start of the interval\n      this.removes[lastIndex] = index;\n    } else if (index < intervalStart) {\n      // New interval\n      this.removes.push(index);\n      this.removes.push(index);\n    } else {\n      // We can't support pending removes that are not descending\n      flushPendingChanges.call(this);\n    }\n  }\n\n  this._pendingLength = this._pendingLength === -1 ? length - 1 : this._pendingLength - 1;\n\n  if (!this.removes) {\n    this.removes = [];\n    this.removes.push(index);\n    this.removes.push(index);\n  }\n}\n/**\n * @private\n * Returns true when all sizes in the specified interval for the block are NaN\n */\n\n\nfunction isIntervalClear(block, index, count) {\n  var sizes = block.sizes,\n      size;\n\n  for (count += index; index < count; ++index) {\n    if ((size = sizes[index]) === size) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * @private\n * Copies elements between blocks. Indices relative to the blocks.\n * If srcBlock is null, then it fills the destination with NaNs.\n * The case of srcBlock === dstBlock is also supported.\n * The caller must ensure that count is within range.\n */\n\n\nfunction inBlockCopy(dstBlock, dstIndexStart, srcBlock, srcIndexStart, count) {\n  var ascending = dstIndexStart < srcIndexStart;\n  var srcIndex = ascending ? srcIndexStart : srcIndexStart + count - 1;\n  var dstIndex = ascending ? dstIndexStart : dstIndexStart + count - 1;\n  var increment = ascending ? +1 : -1;\n  var dstSizes = dstBlock.sizes;\n  var srcSizes = srcBlock ? srcBlock.sizes : null;\n  var dstValue = NaN;\n  var srcValue = NaN;\n  var sizesSumDelta = 0; // How much the destination sizesSum will change\n\n  var defaultCountDelta = 0; // How much the destination defaultCount will change\n\n  while (count > 0) {\n    if (srcSizes) {\n      srcValue = srcSizes[srcIndex];\n    }\n\n    dstValue = dstSizes[dstIndex]; // Are the values different?\n\n    if (srcValue !== dstValue) {\n      // Triple '=' to handle NaN comparison\n      // Are we removing a default size or a chached size?\n      if (dstValue !== dstValue) {\n        defaultCountDelta--;\n      } else {\n        sizesSumDelta -= dstValue;\n      } // Are we adding a default size or a cached size?\n\n\n      if (srcValue !== srcValue) {\n        defaultCountDelta++;\n      } else {\n        sizesSumDelta += srcValue;\n      }\n\n      dstSizes[dstIndex] = srcValue;\n    }\n\n    srcIndex += increment;\n    dstIndex += increment;\n    count--;\n  }\n\n  dstBlock.sizesSum += sizesSumDelta;\n  dstBlock.defaultCount += defaultCountDelta;\n}\n/**\n * @private\n * Copies 'count' elements from dstIndex to srcIndex.\n * Safe for overlapping source and destination intervals.\n * If any blocks are left full of NaNs, they will be deallcated.\n */\n\n\nfunction copyInterval(dstIndex, srcIndex, count) {\n  var ascending = dstIndex < srcIndex;\n\n  if (!ascending) {\n    dstIndex += count - 1;\n    srcIndex += count - 1;\n  }\n\n  while (count > 0) {\n    // Figure out destination block\n    var dstBlockIndex = dstIndex >> this.block_shift;\n    var dstSizesIndex = dstIndex & this.block_mask;\n    var dstBlock = this.block_table[dstBlockIndex]; // Figure out source block\n\n    var srcBlockIndex = srcIndex >> this.block_shift;\n    var srcSizesIndex = srcIndex & this.block_mask;\n    var srcBlock = this.block_table[srcBlockIndex]; // Figure out number of elements to copy\n\n    var copyCount = ascending ? Math.min(this.block_size - dstSizesIndex, this.block_size - srcSizesIndex) : 1 + Math.min(dstSizesIndex, srcSizesIndex);\n    copyCount = Math.min(copyCount, count); // Figure out the start index for each block\n\n    var dstStartIndex = ascending ? dstSizesIndex : dstSizesIndex - copyCount + 1;\n    var srcStartIndex = ascending ? srcSizesIndex : srcSizesIndex - copyCount + 1; // Check whether a destination block needs to be allocated.\n    // Allocate only if there are non-default values to be copied from the source.\n\n    if (srcBlock && !dstBlock && isIntervalClear(srcBlock, srcStartIndex, copyCount)) {\n      dstBlock = new Block(this.block_size);\n      this.block_table[dstBlockIndex] = dstBlock;\n    } // Copy to non-null dstBlock, srcBlock can be null\n\n\n    if (dstBlock) {\n      inBlockCopy(dstBlock, dstStartIndex, srcBlock, srcStartIndex, copyCount); // If this is the last time we're visiting this block, and it contains\n      // only NaNs, then remove it\n\n      if (dstBlock.defaultCount === this.block_size) {\n        var blockEndReached = ascending ? dstStartIndex + copyCount === this.block_size : dstStartIndex === 0;\n        if (blockEndReached || count === copyCount) this.block_table[dstBlockIndex] = null;\n      }\n    }\n\n    dstIndex += ascending ? copyCount : -copyCount;\n    srcIndex += ascending ? copyCount : -copyCount;\n    count -= copyCount;\n  }\n}\n/**\n * @private\n * Sets all elements within the specified interval to NaN (both ends inclusive).\n * Releases empty blocks.\n */\n\n\nfunction clearInterval(start, end) {\n  while (start <= end) {\n    // Figure our destination block\n    var blockIndex = start >> this.block_shift;\n    var sizesIndex = start & this.block_mask;\n    var block = this.block_table[blockIndex]; // Figure out number of elements to clear in this iteration\n    // Make sure we don't clear more items than requested\n\n    var clearCount = this.block_size - sizesIndex;\n    clearCount = Math.min(clearCount, end - start + 1);\n\n    if (block) {\n      if (clearCount === this.block_size) {\n        this.block_table[blockIndex] = null;\n      } else {\n        // Copying from null source block is equivalent of clearing the destination block\n        inBlockCopy(block, sizesIndex, null\n        /*srcBlock*/\n        , 0, clearCount); // If the blockDst contains only default sizes, then remove the block\n\n        if (block.defaultCount === this.block_size) {\n          this.block_table[blockIndex] = null;\n        }\n      }\n    }\n\n    start += clearCount;\n  }\n}\n/**\n * @private\n * Removes the elements designated by the intervals and truncates\n * the LinearLayoutVector to the new length.\n * 'intervals' is a Vector of descending intervals [7, 5, 3, 1]\n */\n\n\nfunction removeIntervals(intervals) {\n  var intervalsCount = intervals.length;\n\n  if (intervalsCount === 0) {\n    return;\n  } // Adding final nextIntervalStart value (see below).\n\n\n  intervals.reverse(); // turn into ascending, for example [7, 5, 3, 1] --> [1, 3, 5, 7]\n\n  intervals.push(this.getLength()); // Move the elements\n\n  var dstStart = intervals[0];\n  var srcStart;\n  var count;\n  var i = 0;\n\n  do {\n    var intervalEnd = intervals[i + 1];\n    var nextIntervalStart = intervals[i + 2];\n    i += 2; // Start copy from after the end of current interval\n\n    srcStart = intervalEnd + 1; // copy all elements up to the start of the next interval.\n\n    count = nextIntervalStart - srcStart;\n    copyInterval.call(this, dstStart, srcStart, count);\n    dstStart += count;\n  } while (i < intervalsCount); // Truncate the excess elements.\n\n\n  this.setLength(dstStart);\n}\n/**\n * @private\n * Increases the length and inserts NaN values for the elements designated by the intervals.\n * 'intervals' is a Vector of ascending intervals [1, 3, 5, 7]\n */\n\n\nfunction insertIntervals(intervals, newLength) {\n  var intervalsCount = intervals.length;\n\n  if (intervalsCount === 0) {\n    return;\n  } // Allocate enough space for the insertions, all the elements\n  // allocated are NaN by default.\n\n\n  var oldLength = this.getLength();\n  this.setLength(newLength);\n  var srcEnd = oldLength - 1;\n  var dstEnd = newLength - 1;\n  var i = intervalsCount - 2;\n\n  while (i >= 0) {\n    // Find current interval\n    var intervalStart = intervals[i];\n    var intervalEnd = intervals[i + 1];\n    i -= 2; // Start after the current interval\n\n    var dstStart = intervalEnd + 1;\n    var copyCount = dstEnd - dstStart + 1;\n    var srcStart = srcEnd - copyCount + 1;\n    copyInterval.call(this, dstStart, srcStart, copyCount);\n    dstStart -= copyCount;\n    dstEnd = intervalStart - 1; // Fill in with default NaN values after the copy\n\n    clearInterval.call(this, intervalStart, intervalEnd);\n  }\n}\n/**\n * @private\n * Processes any pending removes or pending inserts.\n */\n\n\nfunction flushPendingChanges() {\n  var intervals;\n\n  if (this.removes) {\n    intervals = this.removes;\n    this.removes = null;\n    this._pendingLength = -1;\n    removeIntervals.call(this, intervals);\n  } else if (this.inserts) {\n    intervals = this.inserts;\n    var newLength = this._pendingLength;\n    this.inserts = null;\n    this._pendingLength = -1;\n    insertIntervals.call(this, intervals, newLength);\n  }\n}\n/**\n * The cumulative distance to the start of the item at index, including\n * the gaps between items and the axisOffset.\n *\n * The value of start(0) is axisOffset.\n *\n * Equivalent to:\n * <pre>\n * var distance = this.getAxisOffset();\n * for (var i = 0; i &lt; index; i++)\n *     distance += get(i);\n * return distance + (gap * index);\n * </pre>\n *\n * The actual implementation is relatively efficient.\n *\n * @param index The item's index.\n * @see #end\n */\n\n\nfunction start(index) {\n  flushPendingChanges.call(this);\n\n  if (this._length === 0 || index === 0) {\n    return this.getAxisOffset();\n  }\n\n  if (index >= this._length) {\n    throw new Error(\"Invalid index and all that.\");\n  }\n\n  var distance = this.getAxisOffset();\n  var blockIndex = index >> this.block_shift;\n\n  for (var i = 0; i < blockIndex; i++) {\n    var block = this.block_table[i];\n    distance += block ? block.sizesSum + block.defaultCount * this._defaultSize : this.block_size * this._defaultSize;\n  }\n\n  var lastBlock = this.block_table[blockIndex];\n  var lastBlockOffset = index & ~this.block_mask;\n  var lastBlockLength = index - lastBlockOffset;\n\n  if (lastBlock) {\n    var sizes = lastBlock.sizes;\n\n    for (i = 0; i < lastBlockLength; i++) {\n      var size = sizes[i];\n      distance += size !== size ? this._defaultSize : size;\n    }\n  } else {\n    distance += this._defaultSize * lastBlockLength;\n  }\n\n  distance += index * this.getGap();\n  return distance;\n}\n/**\n * The cumulative distance to the end of the item at index, including\n * the gaps between items.\n *\n * If <code>index &lt;(length-1)</code> then the value of this\n * function is defined as:\n * <code>start(index) + get(index)</code>.\n *\n * @param index The item's index.\n * @see #start\n */\n\n\nfunction end(index) {\n  flushPendingChanges.call(this);\n  return this.start(index) + this.getItemSize(index);\n}\n/**\n * Returns the index of the item that overlaps the specified distance.\n *\n * The item at index <code>i</code> overlaps a distance value\n * if <code>start(i) &lt;= distance &lt; end(i)</code>.\n *\n * If no such item exists, -1 is returned.\n */\n\n\nfunction indexOf(distance) {\n  flushPendingChanges.call(this);\n  var index = indexOfInternal.call(this, distance);\n  return index >= this._length ? -1 : index;\n}\n\nfunction indexOfInternal(distance) {\n  if (this._length === 0 || distance < 0) {\n    return -1;\n  } // The area of the first item includes the axisOffset\n\n\n  var curDistance = this.getAxisOffset();\n\n  if (distance < curDistance) {\n    return 0;\n  }\n\n  var index = -1,\n      block = null,\n      blockSize = this.block_size,\n      defaultSize = this._defaultSize,\n      gap = this.getGap(),\n      blockGap = gap * blockSize; // Find the block that contains distance and the index of its\n  // first element\n\n  var blockIndex = -1,\n      blockTable = this.block_table,\n      blockTableLength = blockTable.length;\n\n  for (; ++blockIndex < blockTableLength;) {\n    block = blockTable[blockIndex];\n    var blockDistance = blockGap + (block ? block.sizesSum + block.defaultCount * defaultSize : blockSize * defaultSize);\n\n    if (distance === curDistance || distance >= curDistance && distance < curDistance + blockDistance) {\n      index = blockIndex << this.block_shift;\n      break;\n    }\n\n    curDistance += blockDistance;\n  }\n\n  if (index === -1 || distance === curDistance) {\n    return index;\n  } // At this point index corresponds to the first item in this block\n\n\n  if (block) {\n    // Find the item that contains distance and return its index\n    var sizes = block.sizes,\n        n = this.block_size - 1;\n\n    for (var i = 0; i < n; i++) {\n      var size = sizes[i];\n      curDistance += gap + (size !== size ? this._defaultSize : size);\n\n      if (curDistance > distance) {\n        return index + i;\n      }\n    } // TBD special-case for the very last index\n\n\n    return index + this.block_size - 1;\n  } else {\n    return index + Math.floor(Number(distance - curDistance) / Number(this._defaultSize + gap));\n  }\n}\n/**\n * Clear all cached state, reset length to zero.\n */\n\n\nfunction clear() {\n  // Discard any pending changes, before setting the length\n  // otherwise the length setter will commit the changes.\n  this.removes = null;\n  this.inserts = null;\n  this._pendingLength = -1;\n  this.setLength(0); // clears the this.block_table as well\n}\n\nfunction toString() {\n  return \"LinearLayoutVector { \" + \"length: \" + this._length + \", \" + \"size: \" + this.end(this.getLength() - 1) + \", \" + \"[blocks: \" + this.block_table.length + \"]\" + \", \" + \"gap: \" + this._gap + \", \" + \"defaultSize: \" + this._defaultSize + \", \" + \"pendingRemoves: \" + (this.removes ? this.removes.length : 0) + \", \" + \"pendingInserts: \" + (this.inserts ? this.inserts.length : 0) + \" }\";\n}\n/**\n * @private\n * A LinearLayoutVector block of layout element heights or widths.\n *\n * Total \"distance\" for a Block is: sizesSum + (defaultCount * distanceVector.default).\n */\n\n\nfunction Block(block_size) {\n  this.sizes = new Array(block_size);\n  this.sizesSum = 0;\n  this.defaultCount = block_size;\n\n  for (var i = -1; ++i < block_size;) {\n    this.sizes[i] = NaN;\n  }\n}","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.default = scrollbarSize;\n\nvar _inDOM = _interopRequireDefault(require(\"./inDOM\"));\n\nvar size;\n\nfunction scrollbarSize(recalc) {\n  if (!size && size !== 0 || recalc) {\n    if (_inDOM.default) {\n      var scrollDiv = document.createElement('div');\n      scrollDiv.style.position = 'absolute';\n      scrollDiv.style.top = '-9999px';\n      scrollDiv.style.width = '50px';\n      scrollDiv.style.height = '50px';\n      scrollDiv.style.overflow = 'scroll';\n      document.body.appendChild(scrollDiv);\n      size = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n      document.body.removeChild(scrollDiv);\n    }\n  }\n\n  return size;\n}\n\nmodule.exports = exports[\"default\"];","\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _default = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\nexports.default = _default;\nmodule.exports = exports[\"default\"];","import * as React from 'react';\nexport default function defaultHeaderRowRenderer(_ref) {\n  var className = _ref.className,\n      columns = _ref.columns,\n      style = _ref.style;\n  return React.createElement('div', {\n    className: className,\n    role: 'row',\n    style: style\n  }, columns);\n}\ndefaultHeaderRowRenderer.propTypes = process.env.NODE_ENV === 'production' ? null : bpfrpt_proptype_HeaderRowRendererParams === PropTypes.any ? {} : bpfrpt_proptype_HeaderRowRendererParams;\nimport { bpfrpt_proptype_HeaderRowRendererParams } from './types';\nimport PropTypes from 'prop-types';","var SortDirection = {\n  /**\n   * Sort items in ascending order.\n   * This means arranging from the lowest value to the highest (e.g. a-z, 0-9).\n   */\n  ASC: 'ASC',\n\n  /**\n   * Sort items in descending order.\n   * This means arranging from the highest value to the lowest (e.g. z-a, 9-0).\n   */\n  DESC: 'DESC'\n};\nexport default SortDirection;","import clsx from 'clsx';\nimport PropTypes from 'prop-types';\nimport * as React from 'react';\nimport SortDirection from './SortDirection';\n/**\n * Displayed beside a header to indicate that a Table is currently sorted by this column.\n */\n\nexport default function SortIndicator(_ref) {\n  var sortDirection = _ref.sortDirection;\n  var classNames = clsx('ReactVirtualized__Table__sortableHeaderIcon', {\n    'ReactVirtualized__Table__sortableHeaderIcon--ASC': sortDirection === SortDirection.ASC,\n    'ReactVirtualized__Table__sortableHeaderIcon--DESC': sortDirection === SortDirection.DESC\n  });\n  return React.createElement('svg', {\n    className: classNames,\n    width: 18,\n    height: 18,\n    viewBox: '0 0 24 24'\n  }, sortDirection === SortDirection.ASC ? React.createElement('path', {\n    d: 'M7 14l5-5 5 5z'\n  }) : React.createElement('path', {\n    d: 'M7 10l5 5 5-5z'\n  }), React.createElement('path', {\n    d: 'M0 0h24v24H0z',\n    fill: 'none'\n  }));\n}\nSortIndicator.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  sortDirection: PropTypes.oneOf([SortDirection.ASC, SortDirection.DESC])\n} : {};","import * as React from 'react';\nimport SortIndicator from './SortIndicator';\n/**\n * Default table header renderer.\n */\n\nexport default function defaultHeaderRenderer(_ref) {\n  var dataKey = _ref.dataKey,\n      label = _ref.label,\n      sortBy = _ref.sortBy,\n      sortDirection = _ref.sortDirection;\n  var showSortIndicator = sortBy === dataKey;\n  var children = [React.createElement('span', {\n    className: 'ReactVirtualized__Table__headerTruncatedText',\n    key: 'label',\n    title: typeof label === 'string' ? label : null\n  }, label)];\n\n  if (showSortIndicator) {\n    children.push(React.createElement(SortIndicator, {\n      key: 'SortIndicator',\n      sortDirection: sortDirection\n    }));\n  }\n\n  return children;\n}\ndefaultHeaderRenderer.propTypes = process.env.NODE_ENV === 'production' ? null : bpfrpt_proptype_HeaderRendererParams === PropTypes.any ? {} : bpfrpt_proptype_HeaderRendererParams;\nimport { bpfrpt_proptype_HeaderRendererParams } from './types';\nimport PropTypes from 'prop-types';","import _extends from 'babel-runtime/helpers/extends';\nimport * as React from 'react';\n/**\n * Default row renderer for Table.\n */\n\nexport default function defaultRowRenderer(_ref) {\n  var className = _ref.className,\n      columns = _ref.columns,\n      index = _ref.index,\n      key = _ref.key,\n      onRowClick = _ref.onRowClick,\n      onRowDoubleClick = _ref.onRowDoubleClick,\n      onRowMouseOut = _ref.onRowMouseOut,\n      onRowMouseOver = _ref.onRowMouseOver,\n      onRowRightClick = _ref.onRowRightClick,\n      rowData = _ref.rowData,\n      style = _ref.style;\n  var a11yProps = {\n    'aria-rowindex': index + 1\n  };\n\n  if (onRowClick || onRowDoubleClick || onRowMouseOut || onRowMouseOver || onRowRightClick) {\n    a11yProps['aria-label'] = 'row';\n    a11yProps.tabIndex = 0;\n\n    if (onRowClick) {\n      a11yProps.onClick = function (event) {\n        return onRowClick({\n          event: event,\n          index: index,\n          rowData: rowData\n        });\n      };\n    }\n\n    if (onRowDoubleClick) {\n      a11yProps.onDoubleClick = function (event) {\n        return onRowDoubleClick({\n          event: event,\n          index: index,\n          rowData: rowData\n        });\n      };\n    }\n\n    if (onRowMouseOut) {\n      a11yProps.onMouseOut = function (event) {\n        return onRowMouseOut({\n          event: event,\n          index: index,\n          rowData: rowData\n        });\n      };\n    }\n\n    if (onRowMouseOver) {\n      a11yProps.onMouseOver = function (event) {\n        return onRowMouseOver({\n          event: event,\n          index: index,\n          rowData: rowData\n        });\n      };\n    }\n\n    if (onRowRightClick) {\n      a11yProps.onContextMenu = function (event) {\n        return onRowRightClick({\n          event: event,\n          index: index,\n          rowData: rowData\n        });\n      };\n    }\n  }\n\n  return React.createElement('div', _extends({}, a11yProps, {\n    className: className,\n    key: key,\n    role: 'row',\n    style: style\n  }), columns);\n}\ndefaultRowRenderer.propTypes = process.env.NODE_ENV === 'production' ? null : bpfrpt_proptype_RowRendererParams === PropTypes.any ? {} : bpfrpt_proptype_RowRendererParams;\nimport { bpfrpt_proptype_RowRendererParams } from './types';\nimport PropTypes from 'prop-types';","import _Object$getPrototypeOf from 'babel-runtime/core-js/object/get-prototype-of';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\nimport PropTypes from 'prop-types';\nimport * as React from 'react';\nimport defaultHeaderRenderer from './defaultHeaderRenderer';\nimport defaultCellRenderer from './defaultCellRenderer';\nimport defaultCellDataGetter from './defaultCellDataGetter';\nimport SortDirection from './SortDirection';\n/**\n * Describes the header and cell contents of a table column.\n */\n\nvar Column = function (_React$Component) {\n  _inherits(Column, _React$Component);\n\n  function Column() {\n    _classCallCheck(this, Column);\n\n    return _possibleConstructorReturn(this, (Column.__proto__ || _Object$getPrototypeOf(Column)).apply(this, arguments));\n  }\n\n  return Column;\n}(React.Component);\n\nColumn.defaultProps = {\n  cellDataGetter: defaultCellDataGetter,\n  cellRenderer: defaultCellRenderer,\n  defaultSortDirection: SortDirection.ASC,\n  flexGrow: 0,\n  flexShrink: 1,\n  headerRenderer: defaultHeaderRenderer,\n  style: {}\n};\nexport default Column;\nColumn.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /** Optional aria-label value to set on the column header */\n  'aria-label': PropTypes.string,\n\n  /**\n   * Callback responsible for returning a cell's data, given its :dataKey\n   * ({ columnData: any, dataKey: string, rowData: any }): any\n   */\n  cellDataGetter: PropTypes.func,\n\n  /**\n   * Callback responsible for rendering a cell's contents.\n   * ({ cellData: any, columnData: any, dataKey: string, rowData: any, rowIndex: number }): node\n   */\n  cellRenderer: PropTypes.func,\n\n  /** Optional CSS class to apply to cell */\n  className: PropTypes.string,\n\n  /** Optional additional data passed to this column's :cellDataGetter */\n  columnData: PropTypes.object,\n\n  /** Uniquely identifies the row-data attribute corresponding to this cell */\n  dataKey: PropTypes.any.isRequired,\n\n  /** Optional direction to be used when clicked the first time */\n  defaultSortDirection: PropTypes.oneOf([SortDirection.ASC, SortDirection.DESC]),\n\n  /** If sort is enabled for the table at large, disable it for this column */\n  disableSort: PropTypes.bool,\n\n  /** Flex grow style; defaults to 0 */\n  flexGrow: PropTypes.number,\n\n  /** Flex shrink style; defaults to 1 */\n  flexShrink: PropTypes.number,\n\n  /** Optional CSS class to apply to this column's header */\n  headerClassName: PropTypes.string,\n\n  /**\n   * Optional callback responsible for rendering a column header contents.\n   * ({ columnData: object, dataKey: string, disableSort: boolean, label: node, sortBy: string, sortDirection: string }): PropTypes.node\n   */\n  headerRenderer: PropTypes.func.isRequired,\n\n  /** Optional inline style to apply to this column's header */\n  headerStyle: PropTypes.object,\n\n  /** Optional id to set on the column header */\n  id: PropTypes.string,\n\n  /** Header label for this column */\n  label: PropTypes.node,\n\n  /** Maximum width of column; this property will only be used if :flexGrow is > 0. */\n  maxWidth: PropTypes.number,\n\n  /** Minimum width of column. */\n  minWidth: PropTypes.number,\n\n  /** Optional inline style to apply to cell */\n  style: PropTypes.object,\n\n  /** Flex basis (width) for this column; This value can grow or shrink based on :flexGrow and :flexShrink properties. */\n  width: PropTypes.number.isRequired\n} : {};","/**\n * Default accessor for returning a cell value for a given attribute.\n * This function expects to operate on either a vanilla Object or an Immutable Map.\n * You should override the column's cellDataGetter if your data is some other type of object.\n */\nexport default function defaultCellDataGetter(_ref) {\n  var dataKey = _ref.dataKey,\n      rowData = _ref.rowData;\n\n  if (typeof rowData.get === 'function') {\n    return rowData.get(dataKey);\n  } else {\n    return rowData[dataKey];\n  }\n}\nimport { bpfrpt_proptype_CellDataGetterParams } from './types';","/**\n * Default cell renderer that displays an attribute as a simple string\n * You should override the column's cellRenderer if your data is some other type of object.\n */\nexport default function defaultCellRenderer(_ref) {\n  var cellData = _ref.cellData;\n\n  if (cellData == null) {\n    return '';\n  } else {\n    return String(cellData);\n  }\n}\nimport { bpfrpt_proptype_CellRendererParams } from './types';","export default function calculateSizeAndPositionDataAndUpdateScrollOffset(_ref) {\n  var cellCount = _ref.cellCount,\n      cellSize = _ref.cellSize,\n      computeMetadataCallback = _ref.computeMetadataCallback,\n      computeMetadataCallbackProps = _ref.computeMetadataCallbackProps,\n      nextCellsCount = _ref.nextCellsCount,\n      nextCellSize = _ref.nextCellSize,\n      nextScrollToIndex = _ref.nextScrollToIndex,\n      scrollToIndex = _ref.scrollToIndex,\n      updateScrollOffsetForScrollToIndex = _ref.updateScrollOffsetForScrollToIndex; // Don't compare cell sizes if they are functions because inline functions would cause infinite loops.\n  // In that event users should use the manual recompute methods to inform of changes.\n\n  if (cellCount !== nextCellsCount || (typeof cellSize === 'number' || typeof nextCellSize === 'number') && cellSize !== nextCellSize) {\n    computeMetadataCallback(computeMetadataCallbackProps); // Updated cell metadata may have hidden the previous scrolled-to item.\n    // In this case we should also update the scrollTop to ensure it stays visible.\n\n    if (scrollToIndex >= 0 && scrollToIndex === nextScrollToIndex) {\n      updateScrollOffsetForScrollToIndex();\n    }\n  }\n}\n/**\n * Helper method that determines when to recalculate row or column metadata.\n */","import _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\nimport LinearLayoutVector from 'linear-layout-vector';\n/**\n * Just-in-time calculates and caches size and position information for a collection of cells.\n */\n\nvar CellSizeAndPositionManager = function () {\n  // Measurements for cells up to this index can be trusted; cells afterward should be estimated.\n  function CellSizeAndPositionManager(_ref) {\n    var cellCount = _ref.cellCount,\n        cellSizeGetter = _ref.cellSizeGetter,\n        estimatedCellSize = _ref.estimatedCellSize;\n\n    _classCallCheck(this, CellSizeAndPositionManager);\n\n    this._lastMeasuredIndex = -1;\n    this._cellSizeGetter = cellSizeGetter;\n    this._cellCount = cellCount;\n    this._estimatedCellSize = estimatedCellSize;\n    this._layoutVector = new LinearLayoutVector();\n\n    this._layoutVector.setLength(cellCount);\n\n    this._layoutVector.setDefaultSize(estimatedCellSize);\n  } // Cache of size and position data for cells, mapped by cell index.\n  // Note that invalid values may exist in this map so only rely on cells up to this._lastMeasuredIndex\n\n\n  _createClass(CellSizeAndPositionManager, [{\n    key: 'areOffsetsAdjusted',\n    value: function areOffsetsAdjusted() {\n      return false;\n    }\n  }, {\n    key: 'configure',\n    value: function configure(_ref2) {\n      var cellCount = _ref2.cellCount,\n          estimatedCellSize = _ref2.estimatedCellSize,\n          cellSizeGetter = _ref2.cellSizeGetter;\n      this._cellCount = cellCount;\n      this._estimatedCellSize = estimatedCellSize;\n      this._cellSizeGetter = cellSizeGetter;\n\n      this._layoutVector.setLength(cellCount);\n\n      this._layoutVector.setDefaultSize(estimatedCellSize);\n    }\n  }, {\n    key: 'getCellCount',\n    value: function getCellCount() {\n      return this._cellCount;\n    }\n  }, {\n    key: 'getEstimatedCellSize',\n    value: function getEstimatedCellSize() {\n      return this._estimatedCellSize;\n    }\n  }, {\n    key: 'getLastMeasuredIndex',\n    value: function getLastMeasuredIndex() {\n      return this._lastMeasuredIndex;\n    }\n  }, {\n    key: 'getOffsetAdjustment',\n    value: function getOffsetAdjustment() {\n      return 0;\n    }\n    /**\n     * This method returns the size and position for the cell at the specified index.\n     * It just-in-time calculates (or used cached values) for cells leading up to the index.\n     */\n\n  }, {\n    key: 'getSizeAndPositionOfCell',\n    value: function getSizeAndPositionOfCell(index) {\n      if (index < 0 || index >= this._cellCount) {\n        throw Error('Requested index ' + index + ' is outside of range 0..' + this._cellCount);\n      }\n\n      var vector = this._layoutVector;\n\n      if (index > this._lastMeasuredIndex) {\n        var token = {\n          index: this._lastMeasuredIndex + 1\n        };\n\n        for (var i = token.index; i <= index; token.index = ++i) {\n          var _size = this._cellSizeGetter(token); // undefined or NaN probably means a logic error in the size getter.\n          // null means we're using CellMeasurer and haven't yet measured a given index.\n\n\n          if (_size === undefined || _size !== _size) {\n            throw Error('Invalid size returned for cell ' + i + ' of value ' + _size);\n          } else if (_size !== null) {\n            vector.setItemSize(i, _size);\n          }\n        }\n\n        this._lastMeasuredIndex = Math.min(index, this._cellCount - 1);\n      }\n\n      return {\n        offset: vector.start(index),\n        size: vector.getItemSize(index)\n      };\n    }\n  }, {\n    key: 'getSizeAndPositionOfLastMeasuredCell',\n    value: function getSizeAndPositionOfLastMeasuredCell() {\n      var index = this._lastMeasuredIndex;\n\n      if (index <= 0) {\n        return {\n          offset: 0,\n          size: 0\n        };\n      }\n\n      var vector = this._layoutVector;\n      return {\n        offset: vector.start(index),\n        size: vector.getItemSize(index)\n      };\n    }\n    /**\n     * Total size of all cells being measured.\n     * This value will be completely estimated initially.\n     * As cells are measured, the estimate will be updated.\n     */\n\n  }, {\n    key: 'getTotalSize',\n    value: function getTotalSize() {\n      var lastIndex = this._cellCount - 1;\n      return lastIndex >= 0 ? this._layoutVector.end(lastIndex) : 0;\n    }\n    /**\n     * Determines a new offset that ensures a certain cell is visible, given the current offset.\n     * If the cell is already visible then the current offset will be returned.\n     * If the current offset is too great or small, it will be adjusted just enough to ensure the specified index is visible.\n     *\n     * @param align Desired alignment within container; one of \"auto\" (default), \"start\", or \"end\"\n     * @param containerSize Size (width or height) of the container viewport\n     * @param currentOffset Container's current (x or y) offset\n     * @param totalSize Total size (width or height) of all cells\n     * @return Offset to use to ensure the specified cell is visible\n     */\n\n  }, {\n    key: 'getUpdatedOffsetForIndex',\n    value: function getUpdatedOffsetForIndex(_ref3) {\n      var _ref3$align = _ref3.align,\n          align = _ref3$align === undefined ? 'auto' : _ref3$align,\n          containerSize = _ref3.containerSize,\n          currentOffset = _ref3.currentOffset,\n          targetIndex = _ref3.targetIndex;\n\n      if (containerSize <= 0) {\n        return 0;\n      }\n\n      var datum = this.getSizeAndPositionOfCell(targetIndex);\n      var maxOffset = datum.offset;\n      var minOffset = maxOffset - containerSize + datum.size;\n      var idealOffset = void 0;\n\n      switch (align) {\n        case 'start':\n          idealOffset = maxOffset;\n          break;\n\n        case 'end':\n          idealOffset = minOffset;\n          break;\n\n        case 'center':\n          idealOffset = maxOffset - (containerSize - datum.size) / 2;\n          break;\n\n        default:\n          idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));\n          break;\n      }\n\n      var totalSize = this.getTotalSize();\n      return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n    }\n  }, {\n    key: 'getVisibleCellRange',\n    value: function getVisibleCellRange(params) {\n      if (this.getTotalSize() === 0) {\n        return {};\n      }\n\n      var containerSize = params.containerSize,\n          offset = params.offset;\n      var maxOffset = offset + containerSize - 1;\n      return {\n        start: this._findNearestCell(offset),\n        stop: this._findNearestCell(maxOffset)\n      };\n    }\n    /**\n     * Clear all cached values for cells after the specified index.\n     * This method should be called for any cell that has changed its size.\n     * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionOfCell() is called.\n     */\n\n  }, {\n    key: 'resetCell',\n    value: function resetCell(index) {\n      this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);\n    }\n    /**\n     * Searches for the cell (index) nearest the specified offset.\n     *\n     * If no exact match is found the next lowest cell index will be returned.\n     * This allows partially visible cells (with offsets just before/above the fold) to be visible.\n     */\n\n  }, {\n    key: '_findNearestCell',\n    value: function _findNearestCell(offset) {\n      if (isNaN(offset)) {\n        throw Error('Invalid offset ' + offset + ' specified');\n      }\n\n      var vector = this._layoutVector;\n      var lastIndex = this._cellCount - 1; // Our search algorithms find the nearest match at or below the specified offset.\n      // So make sure the offset is at least 0 or no match will be found.\n\n      var targetOffset = Math.max(0, Math.min(offset, vector.start(lastIndex))); // First interrogate the constant-time lookup table\n\n      var nearestCellIndex = vector.indexOf(targetOffset); // If we haven't yet measured this high, compute sizes for each cell up to the desired offset.\n\n      while (nearestCellIndex > this._lastMeasuredIndex) {\n        // Measure all the cells up to the one we want to find presently.\n        // Do this before the last-index check to ensure the sparse array\n        // is fully populated.\n        this.getSizeAndPositionOfCell(nearestCellIndex); // No need to search and compare again if we're at the end.\n\n        if (nearestCellIndex === lastIndex) {\n          return nearestCellIndex;\n        }\n\n        nearestCellIndex = vector.indexOf(targetOffset); // Guard in case `getSizeAndPositionOfCell` didn't fully measure to\n        // the nearestCellIndex. This might happen scrolling quickly down\n        // and back up on large lists -- possible race with React or DOM?\n\n        if (nearestCellIndex === -1) {\n          nearestCellIndex = this._lastMeasuredIndex;\n          this._lastMeasuredIndex = nearestCellIndex - 1;\n          targetOffset = Math.max(0, Math.min(offset, vector.start(lastIndex)));\n        }\n      }\n\n      return nearestCellIndex;\n    }\n  }]);\n\n  return CellSizeAndPositionManager;\n}();\n\nexport default CellSizeAndPositionManager;\nimport { bpfrpt_proptype_Alignment } from '../types';\nimport { bpfrpt_proptype_CellSizeGetter } from '../types';\nimport { bpfrpt_proptype_VisibleCellRange } from '../types';","var DEFAULT_MAX_ELEMENT_SIZE = 1500000;\nvar CHROME_MAX_ELEMENT_SIZE = 1.67771e7;\n\nvar isBrowser = function isBrowser() {\n  return typeof window !== 'undefined';\n};\n\nvar isChrome = function isChrome() {\n  return !!window.chrome && !!window.chrome.webstore;\n};\n\nexport var getMaxElementSize = function getMaxElementSize() {\n  if (isBrowser()) {\n    if (isChrome()) {\n      return CHROME_MAX_ELEMENT_SIZE;\n    }\n  }\n\n  return DEFAULT_MAX_ELEMENT_SIZE;\n};","import _objectWithoutProperties from 'babel-runtime/helpers/objectWithoutProperties';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\nimport CellSizeAndPositionManager from './CellSizeAndPositionManager';\nimport { getMaxElementSize } from './maxElementSize.js';\n/**\n * Browsers have scroll offset limitations (eg Chrome stops scrolling at ~33.5M pixels where as Edge tops out at ~1.5M pixels).\n * After a certain position, the browser won't allow the user to scroll further (even via JavaScript scroll offset adjustments).\n * This util picks a lower ceiling for max size and artificially adjusts positions within to make it transparent for users.\n */\n\n/**\n * Extends CellSizeAndPositionManager and adds scaling behavior for lists that are too large to fit within a browser's native limits.\n */\n\nvar ScalingCellSizeAndPositionManager = function () {\n  function ScalingCellSizeAndPositionManager(_ref) {\n    var _ref$maxScrollSize = _ref.maxScrollSize,\n        maxScrollSize = _ref$maxScrollSize === undefined ? getMaxElementSize() : _ref$maxScrollSize,\n        params = _objectWithoutProperties(_ref, ['maxScrollSize']);\n\n    _classCallCheck(this, ScalingCellSizeAndPositionManager); // Favor composition over inheritance to simplify IE10 support\n\n\n    this._cellSizeAndPositionManager = new CellSizeAndPositionManager(params);\n    this._maxScrollSize = maxScrollSize;\n  }\n\n  _createClass(ScalingCellSizeAndPositionManager, [{\n    key: 'areOffsetsAdjusted',\n    value: function areOffsetsAdjusted() {\n      return this._cellSizeAndPositionManager.getTotalSize() > this._maxScrollSize;\n    }\n  }, {\n    key: 'configure',\n    value: function configure(params) {\n      this._cellSizeAndPositionManager.configure(params);\n    }\n  }, {\n    key: 'getCellCount',\n    value: function getCellCount() {\n      return this._cellSizeAndPositionManager.getCellCount();\n    }\n  }, {\n    key: 'getEstimatedCellSize',\n    value: function getEstimatedCellSize() {\n      return this._cellSizeAndPositionManager.getEstimatedCellSize();\n    }\n  }, {\n    key: 'getLastMeasuredIndex',\n    value: function getLastMeasuredIndex() {\n      return this._cellSizeAndPositionManager.getLastMeasuredIndex();\n    }\n    /**\n     * Number of pixels a cell at the given position (offset) should be shifted in order to fit within the scaled container.\n     * The offset passed to this function is scaled (safe) as well.\n     */\n\n  }, {\n    key: 'getOffsetAdjustment',\n    value: function getOffsetAdjustment(_ref2) {\n      var containerSize = _ref2.containerSize,\n          offset = _ref2.offset;\n\n      var totalSize = this._cellSizeAndPositionManager.getTotalSize();\n\n      var safeTotalSize = this.getTotalSize();\n\n      var offsetPercentage = this._getOffsetPercentage({\n        containerSize: containerSize,\n        offset: offset,\n        totalSize: safeTotalSize\n      });\n\n      return Math.round(offsetPercentage * (safeTotalSize - totalSize));\n    }\n  }, {\n    key: 'getSizeAndPositionOfCell',\n    value: function getSizeAndPositionOfCell(index) {\n      return this._cellSizeAndPositionManager.getSizeAndPositionOfCell(index);\n    }\n  }, {\n    key: 'getSizeAndPositionOfLastMeasuredCell',\n    value: function getSizeAndPositionOfLastMeasuredCell() {\n      return this._cellSizeAndPositionManager.getSizeAndPositionOfLastMeasuredCell();\n    }\n    /** See CellSizeAndPositionManager#getTotalSize */\n\n  }, {\n    key: 'getTotalSize',\n    value: function getTotalSize() {\n      return Math.min(this._maxScrollSize, this._cellSizeAndPositionManager.getTotalSize());\n    }\n    /** See CellSizeAndPositionManager#getUpdatedOffsetForIndex */\n\n  }, {\n    key: 'getUpdatedOffsetForIndex',\n    value: function getUpdatedOffsetForIndex(_ref3) {\n      var _ref3$align = _ref3.align,\n          align = _ref3$align === undefined ? 'auto' : _ref3$align,\n          containerSize = _ref3.containerSize,\n          currentOffset = _ref3.currentOffset,\n          targetIndex = _ref3.targetIndex;\n      currentOffset = this._safeOffsetToOffset({\n        containerSize: containerSize,\n        offset: currentOffset\n      });\n\n      var offset = this._cellSizeAndPositionManager.getUpdatedOffsetForIndex({\n        align: align,\n        containerSize: containerSize,\n        currentOffset: currentOffset,\n        targetIndex: targetIndex\n      });\n\n      return this._offsetToSafeOffset({\n        containerSize: containerSize,\n        offset: offset\n      });\n    }\n    /** See CellSizeAndPositionManager#getVisibleCellRange */\n\n  }, {\n    key: 'getVisibleCellRange',\n    value: function getVisibleCellRange(_ref4) {\n      var containerSize = _ref4.containerSize,\n          offset = _ref4.offset;\n      offset = this._safeOffsetToOffset({\n        containerSize: containerSize,\n        offset: offset\n      });\n      return this._cellSizeAndPositionManager.getVisibleCellRange({\n        containerSize: containerSize,\n        offset: offset\n      });\n    }\n  }, {\n    key: 'resetCell',\n    value: function resetCell(index) {\n      this._cellSizeAndPositionManager.resetCell(index);\n    }\n  }, {\n    key: '_getOffsetPercentage',\n    value: function _getOffsetPercentage(_ref5) {\n      var containerSize = _ref5.containerSize,\n          offset = _ref5.offset,\n          totalSize = _ref5.totalSize;\n      return totalSize <= containerSize ? 0 : offset / (totalSize - containerSize);\n    }\n  }, {\n    key: '_offsetToSafeOffset',\n    value: function _offsetToSafeOffset(_ref6) {\n      var containerSize = _ref6.containerSize,\n          offset = _ref6.offset;\n\n      var totalSize = this._cellSizeAndPositionManager.getTotalSize();\n\n      var safeTotalSize = this.getTotalSize();\n\n      if (totalSize === safeTotalSize) {\n        return offset;\n      } else {\n        var offsetPercentage = this._getOffsetPercentage({\n          containerSize: containerSize,\n          offset: offset,\n          totalSize: totalSize\n        });\n\n        return Math.round(offsetPercentage * (safeTotalSize - containerSize));\n      }\n    }\n  }, {\n    key: '_safeOffsetToOffset',\n    value: function _safeOffsetToOffset(_ref7) {\n      var containerSize = _ref7.containerSize,\n          offset = _ref7.offset;\n\n      var totalSize = this._cellSizeAndPositionManager.getTotalSize();\n\n      var safeTotalSize = this.getTotalSize();\n\n      if (totalSize === safeTotalSize) {\n        return offset;\n      } else {\n        var offsetPercentage = this._getOffsetPercentage({\n          containerSize: containerSize,\n          offset: offset,\n          totalSize: safeTotalSize\n        });\n\n        return Math.round(offsetPercentage * (totalSize - containerSize));\n      }\n    }\n  }]);\n\n  return ScalingCellSizeAndPositionManager;\n}();\n\nexport default ScalingCellSizeAndPositionManager;\nimport { bpfrpt_proptype_Alignment } from '../types';\nimport { bpfrpt_proptype_CellSizeGetter } from '../types';\nimport { bpfrpt_proptype_VisibleCellRange } from '../types';","import _Object$keys from 'babel-runtime/core-js/object/keys';\n/**\n * Helper utility that updates the specified callback whenever any of the specified indices have changed.\n */\n\nexport default function createCallbackMemoizer() {\n  var requireAllKeys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var cachedIndices = {};\n  return function (_ref) {\n    var callback = _ref.callback,\n        indices = _ref.indices;\n\n    var keys = _Object$keys(indices);\n\n    var allInitialized = !requireAllKeys || keys.every(function (key) {\n      var value = indices[key];\n      return Array.isArray(value) ? value.length > 0 : value >= 0;\n    });\n    var indexChanged = keys.length !== _Object$keys(cachedIndices).length || keys.some(function (key) {\n      var cachedValue = cachedIndices[key];\n      var value = indices[key];\n      return Array.isArray(value) ? cachedValue.join(',') !== value.join(',') : cachedValue !== value;\n    });\n    cachedIndices = indices;\n\n    if (allInitialized && indexChanged) {\n      callback(indices);\n    }\n  };\n}","export var SCROLL_DIRECTION_BACKWARD = -1;\nexport var SCROLL_DIRECTION_FORWARD = 1;\nexport var SCROLL_DIRECTION_HORIZONTAL = 'horizontal';\nexport var SCROLL_DIRECTION_VERTICAL = 'vertical';\n/**\n * Calculates the number of cells to overscan before and after a specified range.\n * This function ensures that overscanning doesn't exceed the available cells.\n */\n\nexport default function defaultOverscanIndicesGetter(_ref) {\n  var cellCount = _ref.cellCount,\n      overscanCellsCount = _ref.overscanCellsCount,\n      scrollDirection = _ref.scrollDirection,\n      startIndex = _ref.startIndex,\n      stopIndex = _ref.stopIndex;\n\n  if (scrollDirection === SCROLL_DIRECTION_FORWARD) {\n    return {\n      overscanStartIndex: Math.max(0, startIndex),\n      overscanStopIndex: Math.min(cellCount - 1, stopIndex + overscanCellsCount)\n    };\n  } else {\n    return {\n      overscanStartIndex: Math.max(0, startIndex - overscanCellsCount),\n      overscanStopIndex: Math.min(cellCount - 1, stopIndex)\n    };\n  }\n}\nimport { bpfrpt_proptype_OverscanIndicesGetterParams } from './types';\nimport { bpfrpt_proptype_OverscanIndices } from './types';","import ScalingCellSizeAndPositionManager from './ScalingCellSizeAndPositionManager.js';\n/**\n * Helper function that determines when to update scroll offsets to ensure that a scroll-to-index remains visible.\n * This function also ensures that the scroll ofset isn't past the last column/row of cells.\n */\n\nexport default function updateScrollIndexHelper(_ref) {\n  var cellSize = _ref.cellSize,\n      cellSizeAndPositionManager = _ref.cellSizeAndPositionManager,\n      previousCellsCount = _ref.previousCellsCount,\n      previousCellSize = _ref.previousCellSize,\n      previousScrollToAlignment = _ref.previousScrollToAlignment,\n      previousScrollToIndex = _ref.previousScrollToIndex,\n      previousSize = _ref.previousSize,\n      scrollOffset = _ref.scrollOffset,\n      scrollToAlignment = _ref.scrollToAlignment,\n      scrollToIndex = _ref.scrollToIndex,\n      size = _ref.size,\n      sizeJustIncreasedFromZero = _ref.sizeJustIncreasedFromZero,\n      updateScrollIndexCallback = _ref.updateScrollIndexCallback;\n  var cellCount = cellSizeAndPositionManager.getCellCount();\n  var hasScrollToIndex = scrollToIndex >= 0 && scrollToIndex < cellCount;\n  var sizeHasChanged = size !== previousSize || sizeJustIncreasedFromZero || !previousCellSize || typeof cellSize === 'number' && cellSize !== previousCellSize; // If we have a new scroll target OR if height/row-height has changed,\n  // We should ensure that the scroll target is visible.\n\n  if (hasScrollToIndex && (sizeHasChanged || scrollToAlignment !== previousScrollToAlignment || scrollToIndex !== previousScrollToIndex)) {\n    updateScrollIndexCallback(scrollToIndex); // If we don't have a selected item but list size or number of children have decreased,\n    // Make sure we aren't scrolled too far past the current content.\n  } else if (!hasScrollToIndex && cellCount > 0 && (size < previousSize || cellCount < previousCellsCount)) {\n    // We need to ensure that the current scroll offset is still within the collection's range.\n    // To do this, we don't need to measure everything; CellMeasurer would perform poorly.\n    // Just check to make sure we're still okay.\n    // Only adjust the scroll position if we've scrolled below the last set of rows.\n    if (scrollOffset > cellSizeAndPositionManager.getTotalSize() - size) {\n      updateScrollIndexCallback(cellCount - 1);\n    }\n  }\n}\nimport { bpfrpt_proptype_Alignment } from '../types';\nimport { bpfrpt_proptype_CellSize } from '../types';","import _Object$assign from 'babel-runtime/core-js/object/assign';\nimport _extends from 'babel-runtime/helpers/extends';\nimport _Object$getPrototypeOf from 'babel-runtime/core-js/object/get-prototype-of';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\nimport * as React from 'react';\nimport clsx from 'clsx';\nimport calculateSizeAndPositionDataAndUpdateScrollOffset from './utils/calculateSizeAndPositionDataAndUpdateScrollOffset';\nimport ScalingCellSizeAndPositionManager from './utils/ScalingCellSizeAndPositionManager';\nimport createCallbackMemoizer from '../utils/createCallbackMemoizer';\nimport defaultOverscanIndicesGetter, { SCROLL_DIRECTION_BACKWARD, SCROLL_DIRECTION_FORWARD } from './defaultOverscanIndicesGetter';\nimport updateScrollIndexHelper from './utils/updateScrollIndexHelper';\nimport defaultCellRangeRenderer from './defaultCellRangeRenderer';\nimport scrollbarSize from 'dom-helpers/util/scrollbarSize';\nimport { polyfill } from 'react-lifecycles-compat';\nimport { requestAnimationTimeout, cancelAnimationTimeout } from '../utils/requestAnimationTimeout';\n/**\n * Specifies the number of milliseconds during which to disable pointer events while a scroll is in progress.\n * This improves performance and makes scrolling smoother.\n */\n\nexport var DEFAULT_SCROLLING_RESET_TIME_INTERVAL = 150;\n/**\n * Controls whether the Grid updates the DOM element's scrollLeft/scrollTop based on the current state or just observes it.\n * This prevents Grid from interrupting mouse-wheel animations (see issue #2).\n */\n\nvar SCROLL_POSITION_CHANGE_REASONS = {\n  OBSERVED: 'observed',\n  REQUESTED: 'requested'\n};\n\nvar renderNull = function renderNull() {\n  return null;\n};\n/**\n * Renders tabular data with virtualization along the vertical and horizontal axes.\n * Row heights and column widths must be known ahead of time and specified as properties.\n */\n\n\nvar Grid = function (_React$PureComponent) {\n  _inherits(Grid, _React$PureComponent); // Invokes onSectionRendered callback only when start/stop row or column indices change\n\n\n  function Grid(props) {\n    _classCallCheck(this, Grid);\n\n    var _this = _possibleConstructorReturn(this, (Grid.__proto__ || _Object$getPrototypeOf(Grid)).call(this, props));\n\n    _this._onGridRenderedMemoizer = createCallbackMemoizer();\n    _this._onScrollMemoizer = createCallbackMemoizer(false);\n    _this._deferredInvalidateColumnIndex = null;\n    _this._deferredInvalidateRowIndex = null;\n    _this._recomputeScrollLeftFlag = false;\n    _this._recomputeScrollTopFlag = false;\n    _this._horizontalScrollBarSize = 0;\n    _this._verticalScrollBarSize = 0;\n    _this._scrollbarPresenceChanged = false;\n    _this._renderedColumnStartIndex = 0;\n    _this._renderedColumnStopIndex = 0;\n    _this._renderedRowStartIndex = 0;\n    _this._renderedRowStopIndex = 0;\n    _this._styleCache = {};\n    _this._cellCache = {};\n\n    _this._debounceScrollEndedCallback = function () {\n      _this._disablePointerEventsTimeoutId = null; // isScrolling is used to determine if we reset styleCache\n\n      _this.setState({\n        isScrolling: false,\n        needToResetStyleCache: false\n      });\n    };\n\n    _this._invokeOnGridRenderedHelper = function () {\n      var onSectionRendered = _this.props.onSectionRendered;\n\n      _this._onGridRenderedMemoizer({\n        callback: onSectionRendered,\n        indices: {\n          columnOverscanStartIndex: _this._columnStartIndex,\n          columnOverscanStopIndex: _this._columnStopIndex,\n          columnStartIndex: _this._renderedColumnStartIndex,\n          columnStopIndex: _this._renderedColumnStopIndex,\n          rowOverscanStartIndex: _this._rowStartIndex,\n          rowOverscanStopIndex: _this._rowStopIndex,\n          rowStartIndex: _this._renderedRowStartIndex,\n          rowStopIndex: _this._renderedRowStopIndex\n        }\n      });\n    };\n\n    _this._setScrollingContainerRef = function (ref) {\n      _this._scrollingContainer = ref;\n    };\n\n    _this._onScroll = function (event) {\n      // In certain edge-cases React dispatches an onScroll event with an invalid target.scrollLeft / target.scrollTop.\n      // This invalid event can be detected by comparing event.target to this component's scrollable DOM element.\n      // See issue #404 for more information.\n      if (event.target === _this._scrollingContainer) {\n        _this.handleScrollEvent(event.target);\n      }\n    };\n\n    var columnSizeAndPositionManager = new ScalingCellSizeAndPositionManager({\n      cellCount: props.columnCount,\n      cellSizeGetter: function cellSizeGetter(params) {\n        return Grid._wrapSizeGetter(props.columnWidth)(params);\n      },\n      estimatedCellSize: Grid._getEstimatedColumnSize(props)\n    });\n    var rowSizeAndPositionManager = new ScalingCellSizeAndPositionManager({\n      cellCount: props.rowCount,\n      cellSizeGetter: function cellSizeGetter(params) {\n        return Grid._wrapSizeGetter(props.rowHeight)(params);\n      },\n      estimatedCellSize: Grid._getEstimatedRowSize(props)\n    });\n    _this.state = {\n      instanceProps: {\n        columnSizeAndPositionManager: columnSizeAndPositionManager,\n        rowSizeAndPositionManager: rowSizeAndPositionManager,\n        prevColumnWidth: props.columnWidth,\n        prevRowHeight: props.rowHeight,\n        prevColumnCount: props.columnCount,\n        prevRowCount: props.rowCount,\n        prevIsScrolling: props.isScrolling === true,\n        prevScrollToColumn: props.scrollToColumn,\n        prevScrollToRow: props.scrollToRow,\n        prevScrollLeft: props.scrollLeft,\n        prevScrollTop: props.scrollTop,\n        scrollbarSize: 0,\n        scrollbarSizeMeasured: false\n      },\n      isScrolling: false,\n      scrollDirectionHorizontal: SCROLL_DIRECTION_FORWARD,\n      scrollDirectionVertical: SCROLL_DIRECTION_FORWARD,\n      scrollLeft: props.scrollLeft || 0,\n      scrollTop: props.scrollTop || 0,\n      scrollPositionChangeReason: null,\n      needToResetStyleCache: false\n    };\n\n    if (props.scrollToRow > 0) {\n      _this._initialScrollTop = _this._getCalculatedScrollTop(props, _this.state);\n    }\n\n    if (props.scrollToColumn > 0) {\n      _this._initialScrollLeft = _this._getCalculatedScrollLeft(props, _this.state);\n    }\n\n    return _this;\n  }\n  /**\n   * Gets offsets for a given cell and alignment.\n   */\n\n\n  _createClass(Grid, [{\n    key: 'getOffsetForCell',\n    value: function getOffsetForCell() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$alignment = _ref.alignment,\n          alignment = _ref$alignment === undefined ? this.props.scrollToAlignment : _ref$alignment,\n          _ref$columnIndex = _ref.columnIndex,\n          columnIndex = _ref$columnIndex === undefined ? this.props.scrollToColumn : _ref$columnIndex,\n          _ref$rowIndex = _ref.rowIndex,\n          rowIndex = _ref$rowIndex === undefined ? this.props.scrollToRow : _ref$rowIndex;\n\n      var offsetProps = _extends({}, this.props, {\n        scrollToAlignment: alignment,\n        scrollToColumn: columnIndex,\n        scrollToRow: rowIndex\n      });\n\n      return {\n        scrollLeft: this._getCalculatedScrollLeft(offsetProps),\n        scrollTop: this._getCalculatedScrollTop(offsetProps)\n      };\n    }\n    /**\n     * Gets estimated total rows' height.\n     */\n\n  }, {\n    key: 'getTotalRowsHeight',\n    value: function getTotalRowsHeight() {\n      return this.state.instanceProps.rowSizeAndPositionManager.getTotalSize();\n    }\n    /**\n     * Gets estimated total columns' width.\n     */\n\n  }, {\n    key: 'getTotalColumnsWidth',\n    value: function getTotalColumnsWidth() {\n      return this.state.instanceProps.columnSizeAndPositionManager.getTotalSize();\n    }\n    /**\n     * This method handles a scroll event originating from an external scroll control.\n     * It's an advanced method and should probably not be used unless you're implementing a custom scroll-bar solution.\n     */\n\n  }, {\n    key: 'handleScrollEvent',\n    value: function handleScrollEvent(_ref2) {\n      var _ref2$scrollLeft = _ref2.scrollLeft,\n          scrollLeftParam = _ref2$scrollLeft === undefined ? 0 : _ref2$scrollLeft,\n          _ref2$scrollTop = _ref2.scrollTop,\n          scrollTopParam = _ref2$scrollTop === undefined ? 0 : _ref2$scrollTop; // On iOS, we can arrive at negative offsets by swiping past the start.\n      // To prevent flicker here, we make playing in the negative offset zone cause nothing to happen.\n\n      if (scrollTopParam < 0) {\n        return;\n      } // Prevent pointer events from interrupting a smooth scroll\n\n\n      this._debounceScrollEnded();\n\n      var _props = this.props,\n          autoHeight = _props.autoHeight,\n          autoWidth = _props.autoWidth,\n          height = _props.height,\n          width = _props.width;\n      var instanceProps = this.state.instanceProps; // When this component is shrunk drastically, React dispatches a series of back-to-back scroll events,\n      // Gradually converging on a scrollTop that is within the bounds of the new, smaller height.\n      // This causes a series of rapid renders that is slow for long lists.\n      // We can avoid that by doing some simple bounds checking to ensure that scroll offsets never exceed their bounds.\n\n      var scrollbarSize = instanceProps.scrollbarSize;\n      var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n      var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n      var scrollLeft = Math.min(Math.max(0, totalColumnsWidth - width + scrollbarSize), scrollLeftParam);\n      var scrollTop = Math.min(Math.max(0, totalRowsHeight - height + scrollbarSize), scrollTopParam); // Certain devices (like Apple touchpad) rapid-fire duplicate events.\n      // Don't force a re-render if this is the case.\n      // The mouse may move faster then the animation frame does.\n      // Use requestAnimationFrame to avoid over-updating.\n\n      if (this.state.scrollLeft !== scrollLeft || this.state.scrollTop !== scrollTop) {\n        // Track scrolling direction so we can more efficiently overscan rows to reduce empty space around the edges while scrolling.\n        // Don't change direction for an axis unless scroll offset has changed.\n        var _scrollDirectionHorizontal = scrollLeft !== this.state.scrollLeft ? scrollLeft > this.state.scrollLeft ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionHorizontal;\n\n        var _scrollDirectionVertical = scrollTop !== this.state.scrollTop ? scrollTop > this.state.scrollTop ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionVertical;\n\n        var newState = {\n          isScrolling: true,\n          scrollDirectionHorizontal: _scrollDirectionHorizontal,\n          scrollDirectionVertical: _scrollDirectionVertical,\n          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.OBSERVED\n        };\n\n        if (!autoHeight) {\n          newState.scrollTop = scrollTop;\n        }\n\n        if (!autoWidth) {\n          newState.scrollLeft = scrollLeft;\n        }\n\n        newState.needToResetStyleCache = false;\n        this.setState(newState);\n      }\n\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop,\n        totalColumnsWidth: totalColumnsWidth,\n        totalRowsHeight: totalRowsHeight\n      });\n    }\n    /**\n     * Invalidate Grid size and recompute visible cells.\n     * This is a deferred wrapper for recomputeGridSize().\n     * It sets a flag to be evaluated on cDM/cDU to avoid unnecessary renders.\n     * This method is intended for advanced use-cases like CellMeasurer.\n     */\n    // @TODO (bvaughn) Add automated test coverage for this.\n\n  }, {\n    key: 'invalidateCellSizeAfterRender',\n    value: function invalidateCellSizeAfterRender(_ref3) {\n      var columnIndex = _ref3.columnIndex,\n          rowIndex = _ref3.rowIndex;\n      this._deferredInvalidateColumnIndex = typeof this._deferredInvalidateColumnIndex === 'number' ? Math.min(this._deferredInvalidateColumnIndex, columnIndex) : columnIndex;\n      this._deferredInvalidateRowIndex = typeof this._deferredInvalidateRowIndex === 'number' ? Math.min(this._deferredInvalidateRowIndex, rowIndex) : rowIndex;\n    }\n    /**\n     * Pre-measure all columns and rows in a Grid.\n     * Typically cells are only measured as needed and estimated sizes are used for cells that have not yet been measured.\n     * This method ensures that the next call to getTotalSize() returns an exact size (as opposed to just an estimated one).\n     */\n\n  }, {\n    key: 'measureAllCells',\n    value: function measureAllCells() {\n      var _props2 = this.props,\n          columnCount = _props2.columnCount,\n          rowCount = _props2.rowCount;\n      var instanceProps = this.state.instanceProps;\n      instanceProps.columnSizeAndPositionManager.getSizeAndPositionOfCell(columnCount - 1);\n      instanceProps.rowSizeAndPositionManager.getSizeAndPositionOfCell(rowCount - 1);\n    }\n    /**\n     * Forced recompute of row heights and column widths.\n     * This function should be called if dynamic column or row sizes have changed but nothing else has.\n     * Since Grid only receives :columnCount and :rowCount it has no way of detecting when the underlying data changes.\n     */\n\n  }, {\n    key: 'recomputeGridSize',\n    value: function recomputeGridSize() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref4$columnIndex = _ref4.columnIndex,\n          columnIndex = _ref4$columnIndex === undefined ? 0 : _ref4$columnIndex,\n          _ref4$rowIndex = _ref4.rowIndex,\n          rowIndex = _ref4$rowIndex === undefined ? 0 : _ref4$rowIndex;\n\n      var _props3 = this.props,\n          scrollToColumn = _props3.scrollToColumn,\n          scrollToRow = _props3.scrollToRow;\n      var instanceProps = this.state.instanceProps;\n      instanceProps.columnSizeAndPositionManager.resetCell(columnIndex);\n      instanceProps.rowSizeAndPositionManager.resetCell(rowIndex); // Cell sizes may be determined by a function property.\n      // In this case the cDU handler can't know if they changed.\n      // Store this flag to let the next cDU pass know it needs to recompute the scroll offset.\n\n      this._recomputeScrollLeftFlag = scrollToColumn >= 0 && (this.state.scrollDirectionHorizontal === SCROLL_DIRECTION_FORWARD ? columnIndex <= scrollToColumn : columnIndex >= scrollToColumn);\n      this._recomputeScrollTopFlag = scrollToRow >= 0 && (this.state.scrollDirectionVertical === SCROLL_DIRECTION_FORWARD ? rowIndex <= scrollToRow : rowIndex >= scrollToRow); // Clear cell cache in case we are scrolling;\n      // Invalid row heights likely mean invalid cached content as well.\n\n      this._styleCache = {};\n      this._cellCache = {};\n      this.forceUpdate();\n    }\n    /**\n     * Ensure column and row are visible.\n     */\n\n  }, {\n    key: 'scrollToCell',\n    value: function scrollToCell(_ref5) {\n      var columnIndex = _ref5.columnIndex,\n          rowIndex = _ref5.rowIndex;\n      var columnCount = this.props.columnCount;\n      var props = this.props; // Don't adjust scroll offset for single-column grids (eg List, Table).\n      // This can cause a funky scroll offset because of the vertical scrollbar width.\n\n      if (columnCount > 1 && columnIndex !== undefined) {\n        this._updateScrollLeftForScrollToColumn(_extends({}, props, {\n          scrollToColumn: columnIndex\n        }));\n      }\n\n      if (rowIndex !== undefined) {\n        this._updateScrollTopForScrollToRow(_extends({}, props, {\n          scrollToRow: rowIndex\n        }));\n      }\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var _props4 = this.props,\n          getScrollbarSize = _props4.getScrollbarSize,\n          height = _props4.height,\n          scrollLeft = _props4.scrollLeft,\n          scrollToColumn = _props4.scrollToColumn,\n          scrollTop = _props4.scrollTop,\n          scrollToRow = _props4.scrollToRow,\n          width = _props4.width;\n      var instanceProps = this.state.instanceProps; // Reset initial offsets to be ignored in browser\n\n      this._initialScrollTop = 0;\n      this._initialScrollLeft = 0; // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.\n      // We must do this at the start of the method as we may calculate and update scroll position below.\n\n      this._handleInvalidatedGridSize(); // If this component was first rendered server-side, scrollbar size will be undefined.\n      // In that event we need to remeasure.\n\n\n      if (!instanceProps.scrollbarSizeMeasured) {\n        this.setState(function (prevState) {\n          var stateUpdate = _extends({}, prevState, {\n            needToResetStyleCache: false\n          });\n\n          stateUpdate.instanceProps.scrollbarSize = getScrollbarSize();\n          stateUpdate.instanceProps.scrollbarSizeMeasured = true;\n          return stateUpdate;\n        });\n      }\n\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0 || typeof scrollTop === 'number' && scrollTop >= 0) {\n        var stateUpdate = Grid._getScrollToPositionStateUpdate({\n          prevState: this.state,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        });\n\n        if (stateUpdate) {\n          stateUpdate.needToResetStyleCache = false;\n          this.setState(stateUpdate);\n        }\n      } // refs don't work in `react-test-renderer`\n\n\n      if (this._scrollingContainer) {\n        // setting the ref's scrollLeft and scrollTop.\n        // Somehow in MultiGrid the main grid doesn't trigger a update on mount.\n        if (this._scrollingContainer.scrollLeft !== this.state.scrollLeft) {\n          this._scrollingContainer.scrollLeft = this.state.scrollLeft;\n        }\n\n        if (this._scrollingContainer.scrollTop !== this.state.scrollTop) {\n          this._scrollingContainer.scrollTop = this.state.scrollTop;\n        }\n      } // Don't update scroll offset if the size is 0; we don't render any cells in this case.\n      // Setting a state may cause us to later thing we've updated the offce when we haven't.\n\n\n      var sizeIsBiggerThanZero = height > 0 && width > 0;\n\n      if (scrollToColumn >= 0 && sizeIsBiggerThanZero) {\n        this._updateScrollLeftForScrollToColumn();\n      }\n\n      if (scrollToRow >= 0 && sizeIsBiggerThanZero) {\n        this._updateScrollTopForScrollToRow();\n      } // Update onRowsRendered callback\n\n\n      this._invokeOnGridRenderedHelper(); // Initialize onScroll callback\n\n\n      this._invokeOnScrollMemoizer({\n        scrollLeft: scrollLeft || 0,\n        scrollTop: scrollTop || 0,\n        totalColumnsWidth: instanceProps.columnSizeAndPositionManager.getTotalSize(),\n        totalRowsHeight: instanceProps.rowSizeAndPositionManager.getTotalSize()\n      });\n\n      this._maybeCallOnScrollbarPresenceChange();\n    }\n    /**\n     * @private\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) New scroll-to-cell props have been set\n     */\n\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this2 = this;\n\n      var _props5 = this.props,\n          autoHeight = _props5.autoHeight,\n          autoWidth = _props5.autoWidth,\n          columnCount = _props5.columnCount,\n          height = _props5.height,\n          rowCount = _props5.rowCount,\n          scrollToAlignment = _props5.scrollToAlignment,\n          scrollToColumn = _props5.scrollToColumn,\n          scrollToRow = _props5.scrollToRow,\n          width = _props5.width;\n      var _state = this.state,\n          scrollLeft = _state.scrollLeft,\n          scrollPositionChangeReason = _state.scrollPositionChangeReason,\n          scrollTop = _state.scrollTop,\n          instanceProps = _state.instanceProps; // If cell sizes have been invalidated (eg we are using CellMeasurer) then reset cached positions.\n      // We must do this at the start of the method as we may calculate and update scroll position below.\n\n      this._handleInvalidatedGridSize(); // Handle edge case where column or row count has only just increased over 0.\n      // In this case we may have to restore a previously-specified scroll offset.\n      // For more info see bvaughn/react-virtualized/issues/218\n\n\n      var columnOrRowCountJustIncreasedFromZero = columnCount > 0 && prevProps.columnCount === 0 || rowCount > 0 && prevProps.rowCount === 0; // Make sure requested changes to :scrollLeft or :scrollTop get applied.\n      // Assigning to scrollLeft/scrollTop tells the browser to interrupt any running scroll animations,\n      // And to discard any pending async changes to the scroll position that may have happened in the meantime (e.g. on a separate scrolling thread).\n      // So we only set these when we require an adjustment of the scroll position.\n      // See issue #2 for more information.\n\n      if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {\n        // @TRICKY :autoHeight and :autoWidth properties instructs Grid to leave :scrollTop and :scrollLeft management to an external HOC (eg WindowScroller).\n        // In this case we should avoid checking scrollingContainer.scrollTop and scrollingContainer.scrollLeft since it forces layout/flow.\n        if (!autoWidth && scrollLeft >= 0 && (scrollLeft !== this._scrollingContainer.scrollLeft || columnOrRowCountJustIncreasedFromZero)) {\n          this._scrollingContainer.scrollLeft = scrollLeft;\n        }\n\n        if (!autoHeight && scrollTop >= 0 && (scrollTop !== this._scrollingContainer.scrollTop || columnOrRowCountJustIncreasedFromZero)) {\n          this._scrollingContainer.scrollTop = scrollTop;\n        }\n      } // Special case where the previous size was 0:\n      // In this case we don't show any windowed cells at all.\n      // So we should always recalculate offset afterwards.\n\n\n      var sizeJustIncreasedFromZero = (prevProps.width === 0 || prevProps.height === 0) && height > 0 && width > 0; // Update scroll offsets if the current :scrollToColumn or :scrollToRow values requires it\n      // @TODO Do we also need this check or can the one in componentWillUpdate() suffice?\n\n      if (this._recomputeScrollLeftFlag) {\n        this._recomputeScrollLeftFlag = false;\n\n        this._updateScrollLeftForScrollToColumn(this.props);\n      } else {\n        updateScrollIndexHelper({\n          cellSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,\n          previousCellsCount: prevProps.columnCount,\n          previousCellSize: prevProps.columnWidth,\n          previousScrollToAlignment: prevProps.scrollToAlignment,\n          previousScrollToIndex: prevProps.scrollToColumn,\n          previousSize: prevProps.width,\n          scrollOffset: scrollLeft,\n          scrollToAlignment: scrollToAlignment,\n          scrollToIndex: scrollToColumn,\n          size: width,\n          sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,\n          updateScrollIndexCallback: function updateScrollIndexCallback() {\n            return _this2._updateScrollLeftForScrollToColumn(_this2.props);\n          }\n        });\n      }\n\n      if (this._recomputeScrollTopFlag) {\n        this._recomputeScrollTopFlag = false;\n\n        this._updateScrollTopForScrollToRow(this.props);\n      } else {\n        updateScrollIndexHelper({\n          cellSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,\n          previousCellsCount: prevProps.rowCount,\n          previousCellSize: prevProps.rowHeight,\n          previousScrollToAlignment: prevProps.scrollToAlignment,\n          previousScrollToIndex: prevProps.scrollToRow,\n          previousSize: prevProps.height,\n          scrollOffset: scrollTop,\n          scrollToAlignment: scrollToAlignment,\n          scrollToIndex: scrollToRow,\n          size: height,\n          sizeJustIncreasedFromZero: sizeJustIncreasedFromZero,\n          updateScrollIndexCallback: function updateScrollIndexCallback() {\n            return _this2._updateScrollTopForScrollToRow(_this2.props);\n          }\n        });\n      } // Update onRowsRendered callback if start/stop indices have changed\n\n\n      this._invokeOnGridRenderedHelper(); // Changes to :scrollLeft or :scrollTop should also notify :onScroll listeners\n\n\n      if (scrollLeft !== prevState.scrollLeft || scrollTop !== prevState.scrollTop) {\n        var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n        var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n\n        this._invokeOnScrollMemoizer({\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          totalColumnsWidth: totalColumnsWidth,\n          totalRowsHeight: totalRowsHeight\n        });\n      }\n\n      this._maybeCallOnScrollbarPresenceChange();\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      if (this._disablePointerEventsTimeoutId) {\n        cancelAnimationTimeout(this._disablePointerEventsTimeoutId);\n      }\n    }\n    /**\n     * This method updates scrollLeft/scrollTop in state for the following conditions:\n     * 1) Empty content (0 rows or columns)\n     * 2) New scroll props overriding the current state\n     * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid\n     */\n\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props6 = this.props,\n          autoContainerWidth = _props6.autoContainerWidth,\n          autoHeight = _props6.autoHeight,\n          autoWidth = _props6.autoWidth,\n          className = _props6.className,\n          containerProps = _props6.containerProps,\n          containerRole = _props6.containerRole,\n          containerStyle = _props6.containerStyle,\n          height = _props6.height,\n          id = _props6.id,\n          noContentRenderer = _props6.noContentRenderer,\n          role = _props6.role,\n          style = _props6.style,\n          tabIndex = _props6.tabIndex,\n          width = _props6.width;\n      var _state2 = this.state,\n          instanceProps = _state2.instanceProps,\n          needToResetStyleCache = _state2.needToResetStyleCache;\n\n      var isScrolling = this._isScrolling();\n\n      var gridStyle = {\n        boxSizing: 'border-box',\n        direction: 'ltr',\n        height: autoHeight ? 'auto' : height,\n        position: 'relative',\n        width: autoWidth ? 'auto' : width,\n        WebkitOverflowScrolling: 'touch',\n        willChange: 'transform'\n      };\n\n      if (needToResetStyleCache) {\n        this._styleCache = {};\n      } // calculate _styleCache here\n      // if state.isScrolling (not from _isScrolling) then reset\n\n\n      if (!this.state.isScrolling) {\n        this._resetStyleCache();\n      } // calculate children to render here\n\n\n      this._calculateChildrenToRender(this.props, this.state);\n\n      var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n      var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize(); // Force browser to hide scrollbars when we know they aren't necessary.\n      // Otherwise once scrollbars appear they may not disappear again.\n      // For more info see issue #116\n\n      var verticalScrollBarSize = totalRowsHeight > height ? instanceProps.scrollbarSize : 0;\n      var horizontalScrollBarSize = totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;\n\n      if (horizontalScrollBarSize !== this._horizontalScrollBarSize || verticalScrollBarSize !== this._verticalScrollBarSize) {\n        this._horizontalScrollBarSize = horizontalScrollBarSize;\n        this._verticalScrollBarSize = verticalScrollBarSize;\n        this._scrollbarPresenceChanged = true;\n      } // Also explicitly init styles to 'auto' if scrollbars are required.\n      // This works around an obscure edge case where external CSS styles have not yet been loaded,\n      // But an initial scroll index of offset is set as an external prop.\n      // Without this style, Grid would render the correct range of cells but would NOT update its internal offset.\n      // This was originally reported via clauderic/react-infinite-calendar/issues/23\n\n\n      gridStyle.overflowX = totalColumnsWidth + verticalScrollBarSize <= width ? 'hidden' : 'auto';\n      gridStyle.overflowY = totalRowsHeight + horizontalScrollBarSize <= height ? 'hidden' : 'auto';\n      var childrenToDisplay = this._childrenToDisplay;\n      var showNoContentRenderer = childrenToDisplay.length === 0 && height > 0 && width > 0;\n      return React.createElement('div', _extends({\n        ref: this._setScrollingContainerRef\n      }, containerProps, {\n        'aria-label': this.props['aria-label'],\n        'aria-readonly': this.props['aria-readonly'],\n        className: clsx('ReactVirtualized__Grid', className),\n        id: id,\n        onScroll: this._onScroll,\n        role: role,\n        style: _extends({}, gridStyle, style),\n        tabIndex: tabIndex\n      }), childrenToDisplay.length > 0 && React.createElement('div', {\n        className: 'ReactVirtualized__Grid__innerScrollContainer',\n        role: containerRole,\n        style: _extends({\n          width: autoContainerWidth ? 'auto' : totalColumnsWidth,\n          height: totalRowsHeight,\n          maxWidth: totalColumnsWidth,\n          maxHeight: totalRowsHeight,\n          overflow: 'hidden',\n          pointerEvents: isScrolling ? 'none' : '',\n          position: 'relative'\n        }, containerStyle)\n      }, childrenToDisplay), showNoContentRenderer && noContentRenderer());\n    }\n    /* ---------------------------- Helper methods ---------------------------- */\n\n  }, {\n    key: '_calculateChildrenToRender',\n    value: function _calculateChildrenToRender() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      var cellRenderer = props.cellRenderer,\n          cellRangeRenderer = props.cellRangeRenderer,\n          columnCount = props.columnCount,\n          deferredMeasurementCache = props.deferredMeasurementCache,\n          height = props.height,\n          overscanColumnCount = props.overscanColumnCount,\n          overscanIndicesGetter = props.overscanIndicesGetter,\n          overscanRowCount = props.overscanRowCount,\n          rowCount = props.rowCount,\n          width = props.width,\n          isScrollingOptOut = props.isScrollingOptOut;\n      var scrollDirectionHorizontal = state.scrollDirectionHorizontal,\n          scrollDirectionVertical = state.scrollDirectionVertical,\n          instanceProps = state.instanceProps;\n      var scrollTop = this._initialScrollTop > 0 ? this._initialScrollTop : state.scrollTop;\n      var scrollLeft = this._initialScrollLeft > 0 ? this._initialScrollLeft : state.scrollLeft;\n\n      var isScrolling = this._isScrolling(props, state);\n\n      this._childrenToDisplay = []; // Render only enough columns and rows to cover the visible area of the grid.\n\n      if (height > 0 && width > 0) {\n        var visibleColumnIndices = instanceProps.columnSizeAndPositionManager.getVisibleCellRange({\n          containerSize: width,\n          offset: scrollLeft\n        });\n        var visibleRowIndices = instanceProps.rowSizeAndPositionManager.getVisibleCellRange({\n          containerSize: height,\n          offset: scrollTop\n        });\n        var horizontalOffsetAdjustment = instanceProps.columnSizeAndPositionManager.getOffsetAdjustment({\n          containerSize: width,\n          offset: scrollLeft\n        });\n        var verticalOffsetAdjustment = instanceProps.rowSizeAndPositionManager.getOffsetAdjustment({\n          containerSize: height,\n          offset: scrollTop\n        }); // Store for _invokeOnGridRenderedHelper()\n\n        this._renderedColumnStartIndex = visibleColumnIndices.start;\n        this._renderedColumnStopIndex = visibleColumnIndices.stop;\n        this._renderedRowStartIndex = visibleRowIndices.start;\n        this._renderedRowStopIndex = visibleRowIndices.stop;\n        var overscanColumnIndices = overscanIndicesGetter({\n          direction: 'horizontal',\n          cellCount: columnCount,\n          overscanCellsCount: overscanColumnCount,\n          scrollDirection: scrollDirectionHorizontal,\n          startIndex: typeof visibleColumnIndices.start === 'number' ? visibleColumnIndices.start : 0,\n          stopIndex: typeof visibleColumnIndices.stop === 'number' ? visibleColumnIndices.stop : -1\n        });\n        var overscanRowIndices = overscanIndicesGetter({\n          direction: 'vertical',\n          cellCount: rowCount,\n          overscanCellsCount: overscanRowCount,\n          scrollDirection: scrollDirectionVertical,\n          startIndex: typeof visibleRowIndices.start === 'number' ? visibleRowIndices.start : 0,\n          stopIndex: typeof visibleRowIndices.stop === 'number' ? visibleRowIndices.stop : -1\n        }); // Store for _invokeOnGridRenderedHelper()\n\n        var columnStartIndex = overscanColumnIndices.overscanStartIndex;\n        var columnStopIndex = overscanColumnIndices.overscanStopIndex;\n        var rowStartIndex = overscanRowIndices.overscanStartIndex;\n        var rowStopIndex = overscanRowIndices.overscanStopIndex; // Advanced use-cases (eg CellMeasurer) require batched measurements to determine accurate sizes.\n\n        if (deferredMeasurementCache) {\n          // If rows have a dynamic height, scan the rows we are about to render.\n          // If any have not yet been measured, then we need to render all columns initially,\n          // Because the height of the row is equal to the tallest cell within that row,\n          // (And so we can't know the height without measuring all column-cells first).\n          if (!deferredMeasurementCache.hasFixedHeight()) {\n            for (var rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {\n              if (!deferredMeasurementCache.has(rowIndex, 0)) {\n                columnStartIndex = 0;\n                columnStopIndex = columnCount - 1;\n                break;\n              }\n            }\n          } // If columns have a dynamic width, scan the columns we are about to render.\n          // If any have not yet been measured, then we need to render all rows initially,\n          // Because the width of the column is equal to the widest cell within that column,\n          // (And so we can't know the width without measuring all row-cells first).\n\n\n          if (!deferredMeasurementCache.hasFixedWidth()) {\n            for (var columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {\n              if (!deferredMeasurementCache.has(0, columnIndex)) {\n                rowStartIndex = 0;\n                rowStopIndex = rowCount - 1;\n                break;\n              }\n            }\n          }\n        }\n\n        this._childrenToDisplay = cellRangeRenderer({\n          cellCache: this._cellCache,\n          cellRenderer: cellRenderer,\n          columnSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,\n          columnStartIndex: columnStartIndex,\n          columnStopIndex: columnStopIndex,\n          deferredMeasurementCache: deferredMeasurementCache,\n          horizontalOffsetAdjustment: horizontalOffsetAdjustment,\n          isScrolling: isScrolling,\n          isScrollingOptOut: isScrollingOptOut,\n          parent: this,\n          rowSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,\n          rowStartIndex: rowStartIndex,\n          rowStopIndex: rowStopIndex,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          styleCache: this._styleCache,\n          verticalOffsetAdjustment: verticalOffsetAdjustment,\n          visibleColumnIndices: visibleColumnIndices,\n          visibleRowIndices: visibleRowIndices\n        }); // update the indices\n\n        this._columnStartIndex = columnStartIndex;\n        this._columnStopIndex = columnStopIndex;\n        this._rowStartIndex = rowStartIndex;\n        this._rowStopIndex = rowStopIndex;\n      }\n    }\n    /**\n     * Sets an :isScrolling flag for a small window of time.\n     * This flag is used to disable pointer events on the scrollable portion of the Grid.\n     * This prevents jerky/stuttery mouse-wheel scrolling.\n     */\n\n  }, {\n    key: '_debounceScrollEnded',\n    value: function _debounceScrollEnded() {\n      var scrollingResetTimeInterval = this.props.scrollingResetTimeInterval;\n\n      if (this._disablePointerEventsTimeoutId) {\n        cancelAnimationTimeout(this._disablePointerEventsTimeoutId);\n      }\n\n      this._disablePointerEventsTimeoutId = requestAnimationTimeout(this._debounceScrollEndedCallback, scrollingResetTimeInterval);\n    }\n  }, {\n    key: '_handleInvalidatedGridSize',\n\n    /**\n     * Check for batched CellMeasurer size invalidations.\n     * This will occur the first time one or more previously unmeasured cells are rendered.\n     */\n    value: function _handleInvalidatedGridSize() {\n      if (typeof this._deferredInvalidateColumnIndex === 'number' && typeof this._deferredInvalidateRowIndex === 'number') {\n        var columnIndex = this._deferredInvalidateColumnIndex;\n        var rowIndex = this._deferredInvalidateRowIndex;\n        this._deferredInvalidateColumnIndex = null;\n        this._deferredInvalidateRowIndex = null;\n        this.recomputeGridSize({\n          columnIndex: columnIndex,\n          rowIndex: rowIndex\n        });\n      }\n    }\n  }, {\n    key: '_invokeOnScrollMemoizer',\n    value: function _invokeOnScrollMemoizer(_ref6) {\n      var _this3 = this;\n\n      var scrollLeft = _ref6.scrollLeft,\n          scrollTop = _ref6.scrollTop,\n          totalColumnsWidth = _ref6.totalColumnsWidth,\n          totalRowsHeight = _ref6.totalRowsHeight;\n\n      this._onScrollMemoizer({\n        callback: function callback(_ref7) {\n          var scrollLeft = _ref7.scrollLeft,\n              scrollTop = _ref7.scrollTop;\n          var _props7 = _this3.props,\n              height = _props7.height,\n              onScroll = _props7.onScroll,\n              width = _props7.width;\n          onScroll({\n            clientHeight: height,\n            clientWidth: width,\n            scrollHeight: totalRowsHeight,\n            scrollLeft: scrollLeft,\n            scrollTop: scrollTop,\n            scrollWidth: totalColumnsWidth\n          });\n        },\n        indices: {\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop\n        }\n      });\n    }\n  }, {\n    key: '_isScrolling',\n    value: function _isScrolling() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state; // If isScrolling is defined in props, use it to override the value in state\n      // This is a performance optimization for WindowScroller + Grid\n\n      return Object.hasOwnProperty.call(props, 'isScrolling') ? Boolean(props.isScrolling) : Boolean(state.isScrolling);\n    }\n  }, {\n    key: '_maybeCallOnScrollbarPresenceChange',\n    value: function _maybeCallOnScrollbarPresenceChange() {\n      if (this._scrollbarPresenceChanged) {\n        var _onScrollbarPresenceChange = this.props.onScrollbarPresenceChange;\n        this._scrollbarPresenceChanged = false;\n\n        _onScrollbarPresenceChange({\n          horizontal: this._horizontalScrollBarSize > 0,\n          size: this.state.instanceProps.scrollbarSize,\n          vertical: this._verticalScrollBarSize > 0\n        });\n      }\n    }\n  }, {\n    key: 'scrollToPosition',\n\n    /**\n     * Scroll to the specified offset(s).\n     * Useful for animating position changes.\n     */\n    value: function scrollToPosition(_ref8) {\n      var scrollLeft = _ref8.scrollLeft,\n          scrollTop = _ref8.scrollTop;\n\n      var stateUpdate = Grid._getScrollToPositionStateUpdate({\n        prevState: this.state,\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop\n      });\n\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }, {\n    key: '_getCalculatedScrollLeft',\n    value: function _getCalculatedScrollLeft() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      return Grid._getCalculatedScrollLeft(props, state);\n    }\n  }, {\n    key: '_updateScrollLeftForScrollToColumn',\n    value: function _updateScrollLeftForScrollToColumn() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n\n      var stateUpdate = Grid._getScrollLeftForScrollToColumnStateUpdate(props, state);\n\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }, {\n    key: '_getCalculatedScrollTop',\n    value: function _getCalculatedScrollTop() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n      return Grid._getCalculatedScrollTop(props, state);\n    }\n  }, {\n    key: '_resetStyleCache',\n    value: function _resetStyleCache() {\n      var styleCache = this._styleCache;\n      var cellCache = this._cellCache;\n      var isScrollingOptOut = this.props.isScrollingOptOut; // Reset cell and style caches once scrolling stops.\n      // This makes Grid simpler to use (since cells commonly change).\n      // And it keeps the caches from growing too large.\n      // Performance is most sensitive when a user is scrolling.\n      // Don't clear visible cells from cellCache if isScrollingOptOut is specified.\n      // This keeps the cellCache to a resonable size.\n\n      this._cellCache = {};\n      this._styleCache = {}; // Copy over the visible cell styles so avoid unnecessary re-render.\n\n      for (var rowIndex = this._rowStartIndex; rowIndex <= this._rowStopIndex; rowIndex++) {\n        for (var columnIndex = this._columnStartIndex; columnIndex <= this._columnStopIndex; columnIndex++) {\n          var key = rowIndex + '-' + columnIndex;\n          this._styleCache[key] = styleCache[key];\n\n          if (isScrollingOptOut) {\n            this._cellCache[key] = cellCache[key];\n          }\n        }\n      }\n    }\n  }, {\n    key: '_updateScrollTopForScrollToRow',\n    value: function _updateScrollTopForScrollToRow() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.state;\n\n      var stateUpdate = Grid._getScrollTopForScrollToRowStateUpdate(props, state);\n\n      if (stateUpdate) {\n        stateUpdate.needToResetStyleCache = false;\n        this.setState(stateUpdate);\n      }\n    }\n  }], [{\n    key: 'getDerivedStateFromProps',\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      var newState = {};\n      var instanceProps = prevState.instanceProps;\n\n      if (nextProps.columnCount === 0 && prevState.scrollLeft !== 0 || nextProps.rowCount === 0 && prevState.scrollTop !== 0) {\n        newState.scrollLeft = 0;\n        newState.scrollTop = 0; // only use scroll{Left,Top} from props if scrollTo{Column,Row} isn't specified\n        // scrollTo{Column,Row} should override scroll{Left,Top}\n      } else if (nextProps.scrollLeft !== instanceProps.prevScrollLeft && nextProps.scrollToColumn < 0 || nextProps.scrollTop !== instanceProps.prevScrollTop && nextProps.scrollToRow < 0) {\n        _Object$assign(newState, Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: nextProps.scrollLeft,\n          scrollTop: nextProps.scrollTop\n        }));\n      } // Initially we should not clearStyleCache\n\n\n      newState.needToResetStyleCache = false;\n\n      if (nextProps.columnWidth !== instanceProps.prevColumnWidth || nextProps.rowHeight !== instanceProps.prevRowHeight) {\n        // Reset cache. set it to {} in render\n        newState.needToResetStyleCache = true;\n      }\n\n      instanceProps.columnSizeAndPositionManager.configure({\n        cellCount: nextProps.columnCount,\n        estimatedCellSize: Grid._getEstimatedColumnSize(nextProps),\n        cellSizeGetter: Grid._wrapSizeGetter(nextProps.columnWidth)\n      });\n      instanceProps.rowSizeAndPositionManager.configure({\n        cellCount: nextProps.rowCount,\n        estimatedCellSize: Grid._getEstimatedRowSize(nextProps),\n        cellSizeGetter: Grid._wrapSizeGetter(nextProps.rowHeight)\n      });\n\n      if (instanceProps.prevColumnCount === 0 || instanceProps.prevRowCount === 0) {\n        instanceProps.prevColumnCount = 0;\n        instanceProps.prevRowCount = 0;\n      } // If scrolling is controlled outside this component, clear cache when scrolling stops\n\n\n      if (nextProps.autoHeight && nextProps.isScrolling === false && instanceProps.prevIsScrolling === true) {\n        _Object$assign(newState, {\n          isScrolling: false\n        });\n      }\n\n      var maybeStateA = void 0;\n      var maybeStateB = void 0;\n      calculateSizeAndPositionDataAndUpdateScrollOffset({\n        cellCount: instanceProps.prevColumnCount,\n        cellSize: typeof instanceProps.prevColumnWidth === 'number' ? instanceProps.prevColumnWidth : null,\n        computeMetadataCallback: function computeMetadataCallback() {\n          return instanceProps.columnSizeAndPositionManager.resetCell(0);\n        },\n        computeMetadataCallbackProps: nextProps,\n        nextCellsCount: nextProps.columnCount,\n        nextCellSize: typeof nextProps.columnWidth === 'number' ? nextProps.columnWidth : null,\n        nextScrollToIndex: nextProps.scrollToColumn,\n        scrollToIndex: instanceProps.prevScrollToColumn,\n        updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {\n          maybeStateA = Grid._getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState);\n        }\n      });\n      calculateSizeAndPositionDataAndUpdateScrollOffset({\n        cellCount: instanceProps.prevRowCount,\n        cellSize: typeof instanceProps.prevRowHeight === 'number' ? instanceProps.prevRowHeight : null,\n        computeMetadataCallback: function computeMetadataCallback() {\n          return instanceProps.rowSizeAndPositionManager.resetCell(0);\n        },\n        computeMetadataCallbackProps: nextProps,\n        nextCellsCount: nextProps.rowCount,\n        nextCellSize: typeof nextProps.rowHeight === 'number' ? nextProps.rowHeight : null,\n        nextScrollToIndex: nextProps.scrollToRow,\n        scrollToIndex: instanceProps.prevScrollToRow,\n        updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {\n          maybeStateB = Grid._getScrollTopForScrollToRowStateUpdate(nextProps, prevState);\n        }\n      });\n      instanceProps.prevColumnCount = nextProps.columnCount;\n      instanceProps.prevColumnWidth = nextProps.columnWidth;\n      instanceProps.prevIsScrolling = nextProps.isScrolling === true;\n      instanceProps.prevRowCount = nextProps.rowCount;\n      instanceProps.prevRowHeight = nextProps.rowHeight;\n      instanceProps.prevScrollToColumn = nextProps.scrollToColumn;\n      instanceProps.prevScrollToRow = nextProps.scrollToRow;\n      instanceProps.prevScrollLeft = nextProps.scrollLeft;\n      instanceProps.prevScrollTop = nextProps.scrollTop; // getting scrollBarSize (moved from componentWillMount)\n\n      instanceProps.scrollbarSize = nextProps.getScrollbarSize();\n\n      if (instanceProps.scrollbarSize === undefined) {\n        instanceProps.scrollbarSizeMeasured = false;\n        instanceProps.scrollbarSize = 0;\n      } else {\n        instanceProps.scrollbarSizeMeasured = true;\n      }\n\n      newState.instanceProps = instanceProps;\n      return _extends({}, newState, maybeStateA, maybeStateB);\n    }\n  }, {\n    key: '_getEstimatedColumnSize',\n    value: function _getEstimatedColumnSize(props) {\n      return typeof props.columnWidth === 'number' ? props.columnWidth : props.estimatedColumnSize;\n    }\n  }, {\n    key: '_getEstimatedRowSize',\n    value: function _getEstimatedRowSize(props) {\n      return typeof props.rowHeight === 'number' ? props.rowHeight : props.estimatedRowSize;\n    }\n  }, {\n    key: '_getScrollToPositionStateUpdate',\n\n    /**\n     * Get the updated state after scrolling to\n     * scrollLeft and scrollTop\n     */\n    value: function _getScrollToPositionStateUpdate(_ref9) {\n      var prevState = _ref9.prevState,\n          scrollLeft = _ref9.scrollLeft,\n          scrollTop = _ref9.scrollTop;\n      var newState = {\n        scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED\n      };\n\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0) {\n        newState.scrollDirectionHorizontal = scrollLeft > prevState.scrollLeft ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_BACKWARD;\n        newState.scrollLeft = scrollLeft;\n      }\n\n      if (typeof scrollTop === 'number' && scrollTop >= 0) {\n        newState.scrollDirectionVertical = scrollTop > prevState.scrollTop ? SCROLL_DIRECTION_FORWARD : SCROLL_DIRECTION_BACKWARD;\n        newState.scrollTop = scrollTop;\n      }\n\n      if (typeof scrollLeft === 'number' && scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft || typeof scrollTop === 'number' && scrollTop >= 0 && scrollTop !== prevState.scrollTop) {\n        return newState;\n      }\n\n      return null;\n    }\n  }, {\n    key: '_wrapSizeGetter',\n    value: function _wrapSizeGetter(value) {\n      return typeof value === 'function' ? value : function () {\n        return value;\n      };\n    }\n  }, {\n    key: '_getCalculatedScrollLeft',\n    value: function _getCalculatedScrollLeft(nextProps, prevState) {\n      var columnCount = nextProps.columnCount,\n          height = nextProps.height,\n          scrollToAlignment = nextProps.scrollToAlignment,\n          scrollToColumn = nextProps.scrollToColumn,\n          width = nextProps.width;\n      var scrollLeft = prevState.scrollLeft,\n          instanceProps = prevState.instanceProps;\n\n      if (columnCount > 0) {\n        var finalColumn = columnCount - 1;\n        var targetIndex = scrollToColumn < 0 ? finalColumn : Math.min(finalColumn, scrollToColumn);\n        var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();\n        var scrollBarSize = instanceProps.scrollbarSizeMeasured && totalRowsHeight > height ? instanceProps.scrollbarSize : 0;\n        return instanceProps.columnSizeAndPositionManager.getUpdatedOffsetForIndex({\n          align: scrollToAlignment,\n          containerSize: width - scrollBarSize,\n          currentOffset: scrollLeft,\n          targetIndex: targetIndex\n        });\n      }\n\n      return 0;\n    }\n  }, {\n    key: '_getScrollLeftForScrollToColumnStateUpdate',\n    value: function _getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState) {\n      var scrollLeft = prevState.scrollLeft;\n\n      var calculatedScrollLeft = Grid._getCalculatedScrollLeft(nextProps, prevState);\n\n      if (typeof calculatedScrollLeft === 'number' && calculatedScrollLeft >= 0 && scrollLeft !== calculatedScrollLeft) {\n        return Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: calculatedScrollLeft,\n          scrollTop: -1\n        });\n      }\n\n      return null;\n    }\n  }, {\n    key: '_getCalculatedScrollTop',\n    value: function _getCalculatedScrollTop(nextProps, prevState) {\n      var height = nextProps.height,\n          rowCount = nextProps.rowCount,\n          scrollToAlignment = nextProps.scrollToAlignment,\n          scrollToRow = nextProps.scrollToRow,\n          width = nextProps.width;\n      var scrollTop = prevState.scrollTop,\n          instanceProps = prevState.instanceProps;\n\n      if (rowCount > 0) {\n        var finalRow = rowCount - 1;\n        var targetIndex = scrollToRow < 0 ? finalRow : Math.min(finalRow, scrollToRow);\n        var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();\n        var scrollBarSize = instanceProps.scrollbarSizeMeasured && totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;\n        return instanceProps.rowSizeAndPositionManager.getUpdatedOffsetForIndex({\n          align: scrollToAlignment,\n          containerSize: height - scrollBarSize,\n          currentOffset: scrollTop,\n          targetIndex: targetIndex\n        });\n      }\n\n      return 0;\n    }\n  }, {\n    key: '_getScrollTopForScrollToRowStateUpdate',\n    value: function _getScrollTopForScrollToRowStateUpdate(nextProps, prevState) {\n      var scrollTop = prevState.scrollTop;\n\n      var calculatedScrollTop = Grid._getCalculatedScrollTop(nextProps, prevState);\n\n      if (typeof calculatedScrollTop === 'number' && calculatedScrollTop >= 0 && scrollTop !== calculatedScrollTop) {\n        return Grid._getScrollToPositionStateUpdate({\n          prevState: prevState,\n          scrollLeft: -1,\n          scrollTop: calculatedScrollTop\n        });\n      }\n\n      return null;\n    }\n  }]);\n\n  return Grid;\n}(React.PureComponent);\n\nGrid.defaultProps = {\n  'aria-label': 'grid',\n  'aria-readonly': true,\n  autoContainerWidth: false,\n  autoHeight: false,\n  autoWidth: false,\n  cellRangeRenderer: defaultCellRangeRenderer,\n  containerRole: 'rowgroup',\n  containerStyle: {},\n  estimatedColumnSize: 100,\n  estimatedRowSize: 30,\n  getScrollbarSize: scrollbarSize,\n  noContentRenderer: renderNull,\n  onScroll: function onScroll() {},\n  onScrollbarPresenceChange: function onScrollbarPresenceChange() {},\n  onSectionRendered: function onSectionRendered() {},\n  overscanColumnCount: 0,\n  overscanIndicesGetter: defaultOverscanIndicesGetter,\n  overscanRowCount: 10,\n  role: 'grid',\n  scrollingResetTimeInterval: DEFAULT_SCROLLING_RESET_TIME_INTERVAL,\n  scrollToAlignment: 'auto',\n  scrollToColumn: -1,\n  scrollToRow: -1,\n  style: {},\n  tabIndex: 0,\n  isScrollingOptOut: false\n};\nGrid.propTypes = process.env.NODE_ENV === 'production' ? null : {\n  \"aria-label\": PropTypes.string.isRequired,\n  \"aria-readonly\": PropTypes.bool,\n\n  /**\n   * Set the width of the inner scrollable container to 'auto'.\n   * This is useful for single-column Grids to ensure that the column doesn't extend below a vertical scrollbar.\n   */\n  autoContainerWidth: PropTypes.bool.isRequired,\n\n  /**\n   * Removes fixed height from the scrollingContainer so that the total height of rows can stretch the window.\n   * Intended for use with WindowScroller\n   */\n  autoHeight: PropTypes.bool.isRequired,\n\n  /**\n   * Removes fixed width from the scrollingContainer so that the total width of rows can stretch the window.\n   * Intended for use with WindowScroller\n   */\n  autoWidth: PropTypes.bool.isRequired,\n\n  /** Responsible for rendering a cell given an row and column index.  */\n  cellRenderer: function cellRenderer() {\n    return (typeof bpfrpt_proptype_CellRenderer === 'function' ? bpfrpt_proptype_CellRenderer.isRequired ? bpfrpt_proptype_CellRenderer.isRequired : bpfrpt_proptype_CellRenderer : PropTypes.shape(bpfrpt_proptype_CellRenderer).isRequired).apply(this, arguments);\n  },\n\n  /** Responsible for rendering a group of cells given their index ranges.  */\n  cellRangeRenderer: function cellRangeRenderer() {\n    return (typeof bpfrpt_proptype_CellRangeRenderer === 'function' ? bpfrpt_proptype_CellRangeRenderer.isRequired ? bpfrpt_proptype_CellRangeRenderer.isRequired : bpfrpt_proptype_CellRangeRenderer : PropTypes.shape(bpfrpt_proptype_CellRangeRenderer).isRequired).apply(this, arguments);\n  },\n\n  /** Optional custom CSS class name to attach to root Grid element.  */\n  className: PropTypes.string,\n\n  /** Number of columns in grid.  */\n  columnCount: PropTypes.number.isRequired,\n\n  /** Either a fixed column width (number) or a function that returns the width of a column given its index.  */\n  columnWidth: function columnWidth() {\n    return (typeof bpfrpt_proptype_CellSize === 'function' ? bpfrpt_proptype_CellSize.isRequired ? bpfrpt_proptype_CellSize.isRequired : bpfrpt_proptype_CellSize : PropTypes.shape(bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);\n  },\n\n  /** Unfiltered props for the Grid container. */\n  containerProps: PropTypes.object,\n\n  /** ARIA role for the cell-container.  */\n  containerRole: PropTypes.string.isRequired,\n\n  /** Optional inline style applied to inner cell-container */\n  containerStyle: PropTypes.object.isRequired,\n\n  /**\n   * If CellMeasurer is used to measure this Grid's children, this should be a pointer to its CellMeasurerCache.\n   * A shared CellMeasurerCache reference enables Grid and CellMeasurer to share measurement data.\n   */\n  deferredMeasurementCache: PropTypes.object,\n\n  /**\n   * Used to estimate the total width of a Grid before all of its columns have actually been measured.\n   * The estimated total width is adjusted as columns are rendered.\n   */\n  estimatedColumnSize: PropTypes.number.isRequired,\n\n  /**\n   * Used to estimate the total height of a Grid before all of its rows have actually been measured.\n   * The estimated total height is adjusted as rows are rendered.\n   */\n  estimatedRowSize: PropTypes.number.isRequired,\n\n  /** Exposed for testing purposes only.  */\n  getScrollbarSize: PropTypes.func.isRequired,\n\n  /** Height of Grid; this property determines the number of visible (vs virtualized) rows.  */\n  height: PropTypes.number.isRequired,\n\n  /** Optional custom id to attach to root Grid element.  */\n  id: PropTypes.string,\n\n  /**\n   * Override internal is-scrolling state tracking.\n   * This property is primarily intended for use with the WindowScroller component.\n   */\n  isScrolling: PropTypes.bool,\n\n  /**\n   * Opt-out of isScrolling param passed to cellRangeRenderer.\n   * To avoid the extra render when scroll stops.\n   */\n  isScrollingOptOut: PropTypes.bool.isRequired,\n\n  /** Optional renderer to be used in place of rows when either :rowCount or :columnCount is 0.  */\n  noContentRenderer: function noContentRenderer() {\n    return (typeof bpfrpt_proptype_NoContentRenderer === 'function' ? bpfrpt_proptype_NoContentRenderer.isRequired ? bpfrpt_proptype_NoContentRenderer.isRequired : bpfrpt_proptype_NoContentRenderer : PropTypes.shape(bpfrpt_proptype_NoContentRenderer).isRequired).apply(this, arguments);\n  },\n\n  /**\n   * Callback invoked whenever the scroll offset changes within the inner scrollable region.\n   * This callback can be used to sync scrolling between lists, tables, or grids.\n   */\n  onScroll: PropTypes.func.isRequired,\n\n  /**\n   * Called whenever a horizontal or vertical scrollbar is added or removed.\n   * This prop is not intended for end-user use;\n   * It is used by MultiGrid to support fixed-row/fixed-column scroll syncing.\n   */\n  onScrollbarPresenceChange: PropTypes.func.isRequired,\n\n  /** Callback invoked with information about the section of the Grid that was just rendered.  */\n  onSectionRendered: PropTypes.func.isRequired,\n\n  /**\n   * Number of columns to render before/after the visible section of the grid.\n   * These columns can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.\n   */\n  overscanColumnCount: PropTypes.number.isRequired,\n\n  /**\n   * Calculates the number of cells to overscan before and after a specified range.\n   * This function ensures that overscanning doesn't exceed the available cells.\n   */\n  overscanIndicesGetter: function overscanIndicesGetter() {\n    return (typeof bpfrpt_proptype_OverscanIndicesGetter === 'function' ? bpfrpt_proptype_OverscanIndicesGetter.isRequired ? bpfrpt_proptype_OverscanIndicesGetter.isRequired : bpfrpt_proptype_OverscanIndicesGetter : PropTypes.shape(bpfrpt_proptype_OverscanIndicesGetter).isRequired).apply(this, arguments);\n  },\n\n  /**\n   * Number of rows to render above/below the visible section of the grid.\n   * These rows can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.\n   */\n  overscanRowCount: PropTypes.number.isRequired,\n\n  /** ARIA role for the grid element.  */\n  role: PropTypes.string.isRequired,\n\n  /**\n   * Either a fixed row height (number) or a function that returns the height of a row given its index.\n   * Should implement the following interface: ({ index: number }): number\n   */\n  rowHeight: function rowHeight() {\n    return (typeof bpfrpt_proptype_CellSize === 'function' ? bpfrpt_proptype_CellSize.isRequired ? bpfrpt_proptype_CellSize.isRequired : bpfrpt_proptype_CellSize : PropTypes.shape(bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);\n  },\n\n  /** Number of rows in grid.  */\n  rowCount: PropTypes.number.isRequired,\n\n  /** Wait this amount of time after the last scroll event before resetting Grid `pointer-events`. */\n  scrollingResetTimeInterval: PropTypes.number.isRequired,\n\n  /** Horizontal offset. */\n  scrollLeft: PropTypes.number,\n\n  /**\n   * Controls scroll-to-cell behavior of the Grid.\n   * The default (\"auto\") scrolls the least amount possible to ensure that the specified cell is fully visible.\n   * Use \"start\" to align cells to the top/left of the Grid and \"end\" to align bottom/right.\n   */\n  scrollToAlignment: function scrollToAlignment() {\n    return (typeof bpfrpt_proptype_Alignment === 'function' ? bpfrpt_proptype_Alignment.isRequired ? bpfrpt_proptype_Alignment.isRequired : bpfrpt_proptype_Alignment : PropTypes.shape(bpfrpt_proptype_Alignment).isRequired).apply(this, arguments);\n  },\n\n  /** Column index to ensure visible (by forcefully scrolling if necessary) */\n  scrollToColumn: PropTypes.number.isRequired,\n\n  /** Vertical offset. */\n  scrollTop: PropTypes.number,\n\n  /** Row index to ensure visible (by forcefully scrolling if necessary) */\n  scrollToRow: PropTypes.number.isRequired,\n\n  /** Optional inline style */\n  style: PropTypes.object.isRequired,\n\n  /** Tab index for focus */\n  tabIndex: PropTypes.number,\n\n  /** Width of Grid; this property determines the number of visible (vs virtualized) columns.  */\n  width: PropTypes.number.isRequired\n};\npolyfill(Grid);\nexport default Grid;\nimport { bpfrpt_proptype_CellRenderer } from './types';\nimport { bpfrpt_proptype_CellRangeRenderer } from './types';\nimport { bpfrpt_proptype_CellPosition } from './types';\nimport { bpfrpt_proptype_CellSize } from './types';\nimport { bpfrpt_proptype_CellSizeGetter } from './types';\nimport { bpfrpt_proptype_NoContentRenderer } from './types';\nimport { bpfrpt_proptype_Scroll } from './types';\nimport { bpfrpt_proptype_ScrollbarPresenceChange } from './types';\nimport { bpfrpt_proptype_RenderedSection } from './types';\nimport { bpfrpt_proptype_OverscanIndicesGetter } from './types';\nimport { bpfrpt_proptype_Alignment } from './types';\nimport { bpfrpt_proptype_CellCache } from './types';\nimport { bpfrpt_proptype_StyleCache } from './types';\nimport { bpfrpt_proptype_AnimationTimeoutId } from '../utils/requestAnimationTimeout';\nimport PropTypes from 'prop-types';","/**\n * Default implementation of cellRangeRenderer used by Grid.\n * This renderer supports cell-caching while the user is scrolling.\n */\nexport default function defaultCellRangeRenderer(_ref) {\n  var cellCache = _ref.cellCache,\n      cellRenderer = _ref.cellRenderer,\n      columnSizeAndPositionManager = _ref.columnSizeAndPositionManager,\n      columnStartIndex = _ref.columnStartIndex,\n      columnStopIndex = _ref.columnStopIndex,\n      deferredMeasurementCache = _ref.deferredMeasurementCache,\n      horizontalOffsetAdjustment = _ref.horizontalOffsetAdjustment,\n      isScrolling = _ref.isScrolling,\n      isScrollingOptOut = _ref.isScrollingOptOut,\n      parent = _ref.parent,\n      rowSizeAndPositionManager = _ref.rowSizeAndPositionManager,\n      rowStartIndex = _ref.rowStartIndex,\n      rowStopIndex = _ref.rowStopIndex,\n      styleCache = _ref.styleCache,\n      verticalOffsetAdjustment = _ref.verticalOffsetAdjustment,\n      visibleColumnIndices = _ref.visibleColumnIndices,\n      visibleRowIndices = _ref.visibleRowIndices;\n  var renderedCells = []; // Browsers have native size limits for elements (eg Chrome 33M pixels, IE 1.5M pixes).\n  // User cannot scroll beyond these size limitations.\n  // In order to work around this, ScalingCellSizeAndPositionManager compresses offsets.\n  // We should never cache styles for compressed offsets though as this can lead to bugs.\n  // See issue #576 for more.\n\n  var areOffsetsAdjusted = columnSizeAndPositionManager.areOffsetsAdjusted() || rowSizeAndPositionManager.areOffsetsAdjusted();\n  var canCacheStyle = !isScrolling && !areOffsetsAdjusted;\n\n  for (var rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {\n    var rowDatum = rowSizeAndPositionManager.getSizeAndPositionOfCell(rowIndex);\n\n    for (var columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {\n      var columnDatum = columnSizeAndPositionManager.getSizeAndPositionOfCell(columnIndex);\n      var isVisible = columnIndex >= visibleColumnIndices.start && columnIndex <= visibleColumnIndices.stop && rowIndex >= visibleRowIndices.start && rowIndex <= visibleRowIndices.stop;\n      var key = rowIndex + '-' + columnIndex;\n      var style = void 0; // Cache style objects so shallow-compare doesn't re-render unnecessarily.\n\n      if (canCacheStyle && styleCache[key]) {\n        style = styleCache[key];\n      } else {\n        // In deferred mode, cells will be initially rendered before we know their size.\n        // Don't interfere with CellMeasurer's measurements by setting an invalid size.\n        if (deferredMeasurementCache && !deferredMeasurementCache.has(rowIndex, columnIndex)) {\n          // Position not-yet-measured cells at top/left 0,0,\n          // And give them width/height of 'auto' so they can grow larger than the parent Grid if necessary.\n          // Positioning them further to the right/bottom influences their measured size.\n          style = {\n            height: 'auto',\n            left: 0,\n            position: 'absolute',\n            top: 0,\n            width: 'auto'\n          };\n        } else {\n          style = {\n            height: rowDatum.size,\n            left: columnDatum.offset + horizontalOffsetAdjustment,\n            position: 'absolute',\n            top: rowDatum.offset + verticalOffsetAdjustment,\n            width: columnDatum.size\n          };\n          styleCache[key] = style;\n        }\n      }\n\n      var cellRendererParams = {\n        columnIndex: columnIndex,\n        isScrolling: isScrolling,\n        isVisible: isVisible,\n        key: key,\n        parent: parent,\n        rowIndex: rowIndex,\n        style: style\n      };\n      var renderedCell = void 0; // Avoid re-creating cells while scrolling.\n      // This can lead to the same cell being created many times and can cause performance issues for \"heavy\" cells.\n      // If a scroll is in progress- cache and reuse cells.\n      // This cache will be thrown away once scrolling completes.\n      // However if we are scaling scroll positions and sizes, we should also avoid caching.\n      // This is because the offset changes slightly as scroll position changes and caching leads to stale values.\n      // For more info refer to issue #395\n      //\n      // If isScrollingOptOut is specified, we always cache cells.\n      // For more info refer to issue #1028\n\n      if ((isScrollingOptOut || isScrolling) && !horizontalOffsetAdjustment && !verticalOffsetAdjustment) {\n        if (!cellCache[key]) {\n          cellCache[key] = cellRenderer(cellRendererParams);\n        }\n\n        renderedCell = cellCache[key]; // If the user is no longer scrolling, don't cache cells.\n        // This makes dynamic cell content difficult for users and would also lead to a heavier memory footprint.\n      } else {\n        renderedCell = cellRenderer(cellRendererParams);\n      }\n\n      if (renderedCell == null || renderedCell === false) {\n        continue;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        warnAboutMissingStyle(parent, renderedCell);\n      }\n\n      renderedCells.push(renderedCell);\n    }\n  }\n\n  return renderedCells;\n}\n\nfunction warnAboutMissingStyle(parent, renderedCell) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (renderedCell) {\n      // If the direct child is a CellMeasurer, then we should check its child\n      // See issue #611\n      if (renderedCell.type && renderedCell.type.__internalCellMeasurerFlag) {\n        renderedCell = renderedCell.props.children;\n      }\n\n      if (renderedCell && renderedCell.props && renderedCell.props.style === undefined && parent.__warnedAboutMissingStyle !== true) {\n        parent.__warnedAboutMissingStyle = true;\n        console.warn('Rendered cell should include style property for positioning.');\n      }\n    }\n  }\n}\n\nimport { bpfrpt_proptype_CellRangeRendererParams } from './types';","export var SCROLL_DIRECTION_BACKWARD = -1;\nexport var SCROLL_DIRECTION_FORWARD = 1;\nexport var SCROLL_DIRECTION_HORIZONTAL = 'horizontal';\nexport var SCROLL_DIRECTION_VERTICAL = 'vertical';\n/**\n * Calculates the number of cells to overscan before and after a specified range.\n * This function ensures that overscanning doesn't exceed the available cells.\n */\n\nexport default function defaultOverscanIndicesGetter(_ref) {\n  var cellCount = _ref.cellCount,\n      overscanCellsCount = _ref.overscanCellsCount,\n      scrollDirection = _ref.scrollDirection,\n      startIndex = _ref.startIndex,\n      stopIndex = _ref.stopIndex; // Make sure we render at least 1 cell extra before and after (except near boundaries)\n  // This is necessary in order to support keyboard navigation (TAB/SHIFT+TAB) in some cases\n  // For more info see issues #625\n\n  overscanCellsCount = Math.max(1, overscanCellsCount);\n\n  if (scrollDirection === SCROLL_DIRECTION_FORWARD) {\n    return {\n      overscanStartIndex: Math.max(0, startIndex - 1),\n      overscanStopIndex: Math.min(cellCount - 1, stopIndex + overscanCellsCount)\n    };\n  } else {\n    return {\n      overscanStartIndex: Math.max(0, startIndex - overscanCellsCount),\n      overscanStopIndex: Math.min(cellCount - 1, stopIndex + 1)\n    };\n  }\n}\nimport { bpfrpt_proptype_OverscanIndicesGetterParams } from './types';\nimport { bpfrpt_proptype_OverscanIndices } from './types';","import _extends from 'babel-runtime/helpers/extends';\nimport _Object$getPrototypeOf from 'babel-runtime/core-js/object/get-prototype-of';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\nimport clsx from 'clsx';\nimport Column from './Column';\nimport PropTypes from 'prop-types';\nimport * as React from 'react';\nimport { findDOMNode } from 'react-dom';\nimport Grid, { accessibilityOverscanIndicesGetter } from '../Grid';\nimport defaultRowRenderer from './defaultRowRenderer';\nimport defaultHeaderRowRenderer from './defaultHeaderRowRenderer';\nimport SortDirection from './SortDirection';\n/**\n * Table component with fixed headers and virtualized rows for improved performance with large data sets.\n * This component expects explicit width, height, and padding parameters.\n */\n\nvar Table = function (_React$PureComponent) {\n  _inherits(Table, _React$PureComponent);\n\n  function Table(props) {\n    _classCallCheck(this, Table);\n\n    var _this = _possibleConstructorReturn(this, (Table.__proto__ || _Object$getPrototypeOf(Table)).call(this, props));\n\n    _this.state = {\n      scrollbarWidth: 0\n    };\n    _this._createColumn = _this._createColumn.bind(_this);\n    _this._createRow = _this._createRow.bind(_this);\n    _this._onScroll = _this._onScroll.bind(_this);\n    _this._onSectionRendered = _this._onSectionRendered.bind(_this);\n    _this._setRef = _this._setRef.bind(_this);\n    return _this;\n  }\n\n  _createClass(Table, [{\n    key: 'forceUpdateGrid',\n    value: function forceUpdateGrid() {\n      if (this.Grid) {\n        this.Grid.forceUpdate();\n      }\n    }\n    /** See Grid#getOffsetForCell */\n\n  }, {\n    key: 'getOffsetForRow',\n    value: function getOffsetForRow(_ref) {\n      var alignment = _ref.alignment,\n          index = _ref.index;\n\n      if (this.Grid) {\n        var _Grid$getOffsetForCel = this.Grid.getOffsetForCell({\n          alignment: alignment,\n          rowIndex: index\n        }),\n            scrollTop = _Grid$getOffsetForCel.scrollTop;\n\n        return scrollTop;\n      }\n\n      return 0;\n    }\n    /** CellMeasurer compatibility */\n\n  }, {\n    key: 'invalidateCellSizeAfterRender',\n    value: function invalidateCellSizeAfterRender(_ref2) {\n      var columnIndex = _ref2.columnIndex,\n          rowIndex = _ref2.rowIndex;\n\n      if (this.Grid) {\n        this.Grid.invalidateCellSizeAfterRender({\n          rowIndex: rowIndex,\n          columnIndex: columnIndex\n        });\n      }\n    }\n    /** See Grid#measureAllCells */\n\n  }, {\n    key: 'measureAllRows',\n    value: function measureAllRows() {\n      if (this.Grid) {\n        this.Grid.measureAllCells();\n      }\n    }\n    /** CellMeasurer compatibility */\n\n  }, {\n    key: 'recomputeGridSize',\n    value: function recomputeGridSize() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref3$columnIndex = _ref3.columnIndex,\n          columnIndex = _ref3$columnIndex === undefined ? 0 : _ref3$columnIndex,\n          _ref3$rowIndex = _ref3.rowIndex,\n          rowIndex = _ref3$rowIndex === undefined ? 0 : _ref3$rowIndex;\n\n      if (this.Grid) {\n        this.Grid.recomputeGridSize({\n          rowIndex: rowIndex,\n          columnIndex: columnIndex\n        });\n      }\n    }\n    /** See Grid#recomputeGridSize */\n\n  }, {\n    key: 'recomputeRowHeights',\n    value: function recomputeRowHeights() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      if (this.Grid) {\n        this.Grid.recomputeGridSize({\n          rowIndex: index\n        });\n      }\n    }\n    /** See Grid#scrollToPosition */\n\n  }, {\n    key: 'scrollToPosition',\n    value: function scrollToPosition() {\n      var scrollTop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      if (this.Grid) {\n        this.Grid.scrollToPosition({\n          scrollTop: scrollTop\n        });\n      }\n    }\n    /** See Grid#scrollToCell */\n\n  }, {\n    key: 'scrollToRow',\n    value: function scrollToRow() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      if (this.Grid) {\n        this.Grid.scrollToCell({\n          columnIndex: 0,\n          rowIndex: index\n        });\n      }\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this._setScrollbarWidth();\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate() {\n      this._setScrollbarWidth();\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      var _props = this.props,\n          children = _props.children,\n          className = _props.className,\n          disableHeader = _props.disableHeader,\n          gridClassName = _props.gridClassName,\n          gridStyle = _props.gridStyle,\n          headerHeight = _props.headerHeight,\n          headerRowRenderer = _props.headerRowRenderer,\n          height = _props.height,\n          id = _props.id,\n          noRowsRenderer = _props.noRowsRenderer,\n          rowClassName = _props.rowClassName,\n          rowStyle = _props.rowStyle,\n          scrollToIndex = _props.scrollToIndex,\n          style = _props.style,\n          width = _props.width;\n      var scrollbarWidth = this.state.scrollbarWidth;\n      var availableRowsHeight = disableHeader ? height : height - headerHeight;\n      var rowClass = typeof rowClassName === 'function' ? rowClassName({\n        index: -1\n      }) : rowClassName;\n      var rowStyleObject = typeof rowStyle === 'function' ? rowStyle({\n        index: -1\n      }) : rowStyle; // Precompute and cache column styles before rendering rows and columns to speed things up\n\n      this._cachedColumnStyles = [];\n      React.Children.toArray(children).forEach(function (column, index) {\n        var flexStyles = _this2._getFlexStyleForColumn(column, column.props.style);\n\n        _this2._cachedColumnStyles[index] = _extends({}, flexStyles, {\n          overflow: 'hidden'\n        });\n      }); // Note that we specify :rowCount, :scrollbarWidth, :sortBy, and :sortDirection as properties on Grid even though these have nothing to do with Grid.\n      // This is done because Grid is a pure component and won't update unless its properties or state has changed.\n      // Any property that should trigger a re-render of Grid then is specified here to avoid a stale display.\n\n      return React.createElement('div', {\n        'aria-label': this.props['aria-label'],\n        'aria-labelledby': this.props['aria-labelledby'],\n        'aria-colcount': React.Children.toArray(children).length,\n        'aria-rowcount': this.props.rowCount,\n        className: clsx('ReactVirtualized__Table', className),\n        id: id,\n        role: 'grid',\n        style: style\n      }, !disableHeader && headerRowRenderer({\n        className: clsx('ReactVirtualized__Table__headerRow', rowClass),\n        columns: this._getHeaderColumns(),\n        style: _extends({\n          height: headerHeight,\n          overflow: 'hidden',\n          paddingRight: scrollbarWidth,\n          width: width\n        }, rowStyleObject)\n      }), React.createElement(Grid, _extends({}, this.props, {\n        autoContainerWidth: true,\n        className: clsx('ReactVirtualized__Table__Grid', gridClassName),\n        cellRenderer: this._createRow,\n        columnWidth: width,\n        columnCount: 1,\n        height: availableRowsHeight,\n        id: undefined,\n        noContentRenderer: noRowsRenderer,\n        onScroll: this._onScroll,\n        onSectionRendered: this._onSectionRendered,\n        ref: this._setRef,\n        role: 'rowgroup',\n        scrollbarWidth: scrollbarWidth,\n        scrollToRow: scrollToIndex,\n        style: _extends({}, gridStyle, {\n          overflowX: 'hidden'\n        })\n      })));\n    }\n  }, {\n    key: '_createColumn',\n    value: function _createColumn(_ref4) {\n      var column = _ref4.column,\n          columnIndex = _ref4.columnIndex,\n          isScrolling = _ref4.isScrolling,\n          parent = _ref4.parent,\n          rowData = _ref4.rowData,\n          rowIndex = _ref4.rowIndex;\n      var onColumnClick = this.props.onColumnClick;\n      var _column$props = column.props,\n          cellDataGetter = _column$props.cellDataGetter,\n          cellRenderer = _column$props.cellRenderer,\n          className = _column$props.className,\n          columnData = _column$props.columnData,\n          dataKey = _column$props.dataKey,\n          id = _column$props.id;\n      var cellData = cellDataGetter({\n        columnData: columnData,\n        dataKey: dataKey,\n        rowData: rowData\n      });\n      var renderedCell = cellRenderer({\n        cellData: cellData,\n        columnData: columnData,\n        columnIndex: columnIndex,\n        dataKey: dataKey,\n        isScrolling: isScrolling,\n        parent: parent,\n        rowData: rowData,\n        rowIndex: rowIndex\n      });\n\n      var onClick = function onClick(event) {\n        onColumnClick && onColumnClick({\n          columnData: columnData,\n          dataKey: dataKey,\n          event: event\n        });\n      };\n\n      var style = this._cachedColumnStyles[columnIndex];\n      var title = typeof renderedCell === 'string' ? renderedCell : null; // Avoid using object-spread syntax with multiple objects here,\n      // Since it results in an extra method call to 'babel-runtime/helpers/extends'\n      // See PR https://github.com/bvaughn/react-virtualized/pull/942\n\n      return React.createElement('div', {\n        'aria-colindex': columnIndex + 1,\n        'aria-describedby': id,\n        className: clsx('ReactVirtualized__Table__rowColumn', className),\n        key: 'Row' + rowIndex + '-' + 'Col' + columnIndex,\n        onClick: onClick,\n        role: 'gridcell',\n        style: style,\n        title: title\n      }, renderedCell);\n    }\n  }, {\n    key: '_createHeader',\n    value: function _createHeader(_ref5) {\n      var column = _ref5.column,\n          index = _ref5.index;\n      var _props2 = this.props,\n          headerClassName = _props2.headerClassName,\n          headerStyle = _props2.headerStyle,\n          onHeaderClick = _props2.onHeaderClick,\n          sort = _props2.sort,\n          sortBy = _props2.sortBy,\n          sortDirection = _props2.sortDirection;\n      var _column$props2 = column.props,\n          columnData = _column$props2.columnData,\n          dataKey = _column$props2.dataKey,\n          defaultSortDirection = _column$props2.defaultSortDirection,\n          disableSort = _column$props2.disableSort,\n          headerRenderer = _column$props2.headerRenderer,\n          id = _column$props2.id,\n          label = _column$props2.label;\n      var sortEnabled = !disableSort && sort;\n      var classNames = clsx('ReactVirtualized__Table__headerColumn', headerClassName, column.props.headerClassName, {\n        ReactVirtualized__Table__sortableHeaderColumn: sortEnabled\n      });\n\n      var style = this._getFlexStyleForColumn(column, _extends({}, headerStyle, column.props.headerStyle));\n\n      var renderedHeader = headerRenderer({\n        columnData: columnData,\n        dataKey: dataKey,\n        disableSort: disableSort,\n        label: label,\n        sortBy: sortBy,\n        sortDirection: sortDirection\n      });\n      var headerOnClick = void 0,\n          headerOnKeyDown = void 0,\n          headerTabIndex = void 0,\n          headerAriaSort = void 0,\n          headerAriaLabel = void 0;\n\n      if (sortEnabled || onHeaderClick) {\n        // If this is a sortable header, clicking it should update the table data's sorting.\n        var isFirstTimeSort = sortBy !== dataKey; // If this is the firstTime sort of this column, use the column default sort order.\n        // Otherwise, invert the direction of the sort.\n\n        var newSortDirection = isFirstTimeSort ? defaultSortDirection : sortDirection === SortDirection.DESC ? SortDirection.ASC : SortDirection.DESC;\n\n        var onClick = function onClick(event) {\n          sortEnabled && sort({\n            defaultSortDirection: defaultSortDirection,\n            event: event,\n            sortBy: dataKey,\n            sortDirection: newSortDirection\n          });\n          onHeaderClick && onHeaderClick({\n            columnData: columnData,\n            dataKey: dataKey,\n            event: event\n          });\n        };\n\n        var onKeyDown = function onKeyDown(event) {\n          if (event.key === 'Enter' || event.key === ' ') {\n            onClick(event);\n          }\n        };\n\n        headerAriaLabel = column.props['aria-label'] || label || dataKey;\n        headerAriaSort = 'none';\n        headerTabIndex = 0;\n        headerOnClick = onClick;\n        headerOnKeyDown = onKeyDown;\n      }\n\n      if (sortBy === dataKey) {\n        headerAriaSort = sortDirection === SortDirection.ASC ? 'ascending' : 'descending';\n      } // Avoid using object-spread syntax with multiple objects here,\n      // Since it results in an extra method call to 'babel-runtime/helpers/extends'\n      // See PR https://github.com/bvaughn/react-virtualized/pull/942\n\n\n      return React.createElement('div', {\n        'aria-label': headerAriaLabel,\n        'aria-sort': headerAriaSort,\n        className: classNames,\n        id: id,\n        key: 'Header-Col' + index,\n        onClick: headerOnClick,\n        onKeyDown: headerOnKeyDown,\n        role: 'columnheader',\n        style: style,\n        tabIndex: headerTabIndex\n      }, renderedHeader);\n    }\n  }, {\n    key: '_createRow',\n    value: function _createRow(_ref6) {\n      var _this3 = this;\n\n      var index = _ref6.rowIndex,\n          isScrolling = _ref6.isScrolling,\n          key = _ref6.key,\n          parent = _ref6.parent,\n          style = _ref6.style;\n      var _props3 = this.props,\n          children = _props3.children,\n          onRowClick = _props3.onRowClick,\n          onRowDoubleClick = _props3.onRowDoubleClick,\n          onRowRightClick = _props3.onRowRightClick,\n          onRowMouseOver = _props3.onRowMouseOver,\n          onRowMouseOut = _props3.onRowMouseOut,\n          rowClassName = _props3.rowClassName,\n          rowGetter = _props3.rowGetter,\n          rowRenderer = _props3.rowRenderer,\n          rowStyle = _props3.rowStyle;\n      var scrollbarWidth = this.state.scrollbarWidth;\n      var rowClass = typeof rowClassName === 'function' ? rowClassName({\n        index: index\n      }) : rowClassName;\n      var rowStyleObject = typeof rowStyle === 'function' ? rowStyle({\n        index: index\n      }) : rowStyle;\n      var rowData = rowGetter({\n        index: index\n      });\n      var columns = React.Children.toArray(children).map(function (column, columnIndex) {\n        return _this3._createColumn({\n          column: column,\n          columnIndex: columnIndex,\n          isScrolling: isScrolling,\n          parent: parent,\n          rowData: rowData,\n          rowIndex: index,\n          scrollbarWidth: scrollbarWidth\n        });\n      });\n      var className = clsx('ReactVirtualized__Table__row', rowClass);\n\n      var flattenedStyle = _extends({}, style, {\n        height: this._getRowHeight(index),\n        overflow: 'hidden',\n        paddingRight: scrollbarWidth\n      }, rowStyleObject);\n\n      return rowRenderer({\n        className: className,\n        columns: columns,\n        index: index,\n        isScrolling: isScrolling,\n        key: key,\n        onRowClick: onRowClick,\n        onRowDoubleClick: onRowDoubleClick,\n        onRowRightClick: onRowRightClick,\n        onRowMouseOver: onRowMouseOver,\n        onRowMouseOut: onRowMouseOut,\n        rowData: rowData,\n        style: flattenedStyle\n      });\n    }\n    /**\n     * Determines the flex-shrink, flex-grow, and width values for a cell (header or column).\n     */\n\n  }, {\n    key: '_getFlexStyleForColumn',\n    value: function _getFlexStyleForColumn(column) {\n      var customStyle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var flexValue = column.props.flexGrow + ' ' + column.props.flexShrink + ' ' + column.props.width + 'px';\n\n      var style = _extends({}, customStyle, {\n        flex: flexValue,\n        msFlex: flexValue,\n        WebkitFlex: flexValue\n      });\n\n      if (column.props.maxWidth) {\n        style.maxWidth = column.props.maxWidth;\n      }\n\n      if (column.props.minWidth) {\n        style.minWidth = column.props.minWidth;\n      }\n\n      return style;\n    }\n  }, {\n    key: '_getHeaderColumns',\n    value: function _getHeaderColumns() {\n      var _this4 = this;\n\n      var _props4 = this.props,\n          children = _props4.children,\n          disableHeader = _props4.disableHeader;\n      var items = disableHeader ? [] : React.Children.toArray(children);\n      return items.map(function (column, index) {\n        return _this4._createHeader({\n          column: column,\n          index: index\n        });\n      });\n    }\n  }, {\n    key: '_getRowHeight',\n    value: function _getRowHeight(rowIndex) {\n      var rowHeight = this.props.rowHeight;\n      return typeof rowHeight === 'function' ? rowHeight({\n        index: rowIndex\n      }) : rowHeight;\n    }\n  }, {\n    key: '_onScroll',\n    value: function _onScroll(_ref7) {\n      var clientHeight = _ref7.clientHeight,\n          scrollHeight = _ref7.scrollHeight,\n          scrollTop = _ref7.scrollTop;\n      var onScroll = this.props.onScroll;\n      onScroll({\n        clientHeight: clientHeight,\n        scrollHeight: scrollHeight,\n        scrollTop: scrollTop\n      });\n    }\n  }, {\n    key: '_onSectionRendered',\n    value: function _onSectionRendered(_ref8) {\n      var rowOverscanStartIndex = _ref8.rowOverscanStartIndex,\n          rowOverscanStopIndex = _ref8.rowOverscanStopIndex,\n          rowStartIndex = _ref8.rowStartIndex,\n          rowStopIndex = _ref8.rowStopIndex;\n      var onRowsRendered = this.props.onRowsRendered;\n      onRowsRendered({\n        overscanStartIndex: rowOverscanStartIndex,\n        overscanStopIndex: rowOverscanStopIndex,\n        startIndex: rowStartIndex,\n        stopIndex: rowStopIndex\n      });\n    }\n  }, {\n    key: '_setRef',\n    value: function _setRef(ref) {\n      this.Grid = ref;\n    }\n  }, {\n    key: '_setScrollbarWidth',\n    value: function _setScrollbarWidth() {\n      if (this.Grid) {\n        var _Grid = findDOMNode(this.Grid);\n\n        var clientWidth = _Grid.clientWidth || 0;\n        var offsetWidth = _Grid.offsetWidth || 0;\n        var scrollbarWidth = offsetWidth - clientWidth;\n        this.setState({\n          scrollbarWidth: scrollbarWidth\n        });\n      }\n    }\n  }]);\n\n  return Table;\n}(React.PureComponent);\n\nTable.defaultProps = {\n  disableHeader: false,\n  estimatedRowSize: 30,\n  headerHeight: 0,\n  headerStyle: {},\n  noRowsRenderer: function noRowsRenderer() {\n    return null;\n  },\n  onRowsRendered: function onRowsRendered() {\n    return null;\n  },\n  onScroll: function onScroll() {\n    return null;\n  },\n  overscanIndicesGetter: accessibilityOverscanIndicesGetter,\n  overscanRowCount: 10,\n  rowRenderer: defaultRowRenderer,\n  headerRowRenderer: defaultHeaderRowRenderer,\n  rowStyle: {},\n  scrollToAlignment: 'auto',\n  scrollToIndex: -1,\n  style: {}\n};\nexport default Table;\nTable.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /** This is just set on the grid top element. */\n  'aria-label': PropTypes.string,\n\n  /** This is just set on the grid top element. */\n  'aria-labelledby': PropTypes.string,\n\n  /**\n   * Removes fixed height from the scrollingContainer so that the total height\n   * of rows can stretch the window. Intended for use with WindowScroller\n   */\n  autoHeight: PropTypes.bool,\n\n  /** One or more Columns describing the data displayed in this row */\n  children: function children(props) {\n    var children = React.Children.toArray(props.children);\n\n    for (var i = 0; i < children.length; i++) {\n      var childType = children[i].type;\n\n      if (childType !== Column && !(childType.prototype instanceof Column)) {\n        return new Error('Table only accepts children of type Column');\n      }\n    }\n  },\n\n  /** Optional CSS class name */\n  className: PropTypes.string,\n\n  /** Disable rendering the header at all */\n  disableHeader: PropTypes.bool,\n\n  /**\n   * Used to estimate the total height of a Table before all of its rows have actually been measured.\n   * The estimated total height is adjusted as rows are rendered.\n   */\n  estimatedRowSize: PropTypes.number.isRequired,\n\n  /** Optional custom CSS class name to attach to inner Grid element. */\n  gridClassName: PropTypes.string,\n\n  /** Optional inline style to attach to inner Grid element. */\n  gridStyle: PropTypes.object,\n\n  /** Optional CSS class to apply to all column headers */\n  headerClassName: PropTypes.string,\n\n  /** Fixed height of header row */\n  headerHeight: PropTypes.number.isRequired,\n\n  /**\n   * Responsible for rendering a table row given an array of columns:\n   * Should implement the following interface: ({\n   *   className: string,\n   *   columns: any[],\n   *   style: any\n   * }): PropTypes.node\n   */\n  headerRowRenderer: PropTypes.func,\n\n  /** Optional custom inline style to attach to table header columns. */\n  headerStyle: PropTypes.object,\n\n  /** Fixed/available height for out DOM element */\n  height: PropTypes.number.isRequired,\n\n  /** Optional id */\n  id: PropTypes.string,\n\n  /** Optional renderer to be used in place of table body rows when rowCount is 0 */\n  noRowsRenderer: PropTypes.func,\n\n  /**\n   * Optional callback when a column is clicked.\n   * ({ columnData: any, dataKey: string }): void\n   */\n  onColumnClick: PropTypes.func,\n\n  /**\n   * Optional callback when a column's header is clicked.\n   * ({ columnData: any, dataKey: string }): void\n   */\n  onHeaderClick: PropTypes.func,\n\n  /**\n   * Callback invoked when a user clicks on a table row.\n   * ({ index: number }): void\n   */\n  onRowClick: PropTypes.func,\n\n  /**\n   * Callback invoked when a user double-clicks on a table row.\n   * ({ index: number }): void\n   */\n  onRowDoubleClick: PropTypes.func,\n\n  /**\n   * Callback invoked when the mouse leaves a table row.\n   * ({ index: number }): void\n   */\n  onRowMouseOut: PropTypes.func,\n\n  /**\n   * Callback invoked when a user moves the mouse over a table row.\n   * ({ index: number }): void\n   */\n  onRowMouseOver: PropTypes.func,\n\n  /**\n   * Callback invoked when a user right-clicks on a table row.\n   * ({ index: number }): void\n   */\n  onRowRightClick: PropTypes.func,\n\n  /**\n   * Callback invoked with information about the slice of rows that were just rendered.\n   * ({ startIndex, stopIndex }): void\n   */\n  onRowsRendered: PropTypes.func,\n\n  /**\n   * Callback invoked whenever the scroll offset changes within the inner scrollable region.\n   * This callback can be used to sync scrolling between lists, tables, or grids.\n   * ({ clientHeight, scrollHeight, scrollTop }): void\n   */\n  onScroll: PropTypes.func.isRequired,\n\n  /** See Grid#overscanIndicesGetter */\n  overscanIndicesGetter: PropTypes.func.isRequired,\n\n  /**\n   * Number of rows to render above/below the visible bounds of the list.\n   * These rows can help for smoother scrolling on touch devices.\n   */\n  overscanRowCount: PropTypes.number.isRequired,\n\n  /**\n   * Optional CSS class to apply to all table rows (including the header row).\n   * This property can be a CSS class name (string) or a function that returns a class name.\n   * If a function is provided its signature should be: ({ index: number }): string\n   */\n  rowClassName: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n\n  /**\n   * Callback responsible for returning a data row given an index.\n   * ({ index: number }): any\n   */\n  rowGetter: PropTypes.func.isRequired,\n\n  /**\n   * Either a fixed row height (number) or a function that returns the height of a row given its index.\n   * ({ index: number }): number\n   */\n  rowHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.func]).isRequired,\n\n  /** Number of rows in table. */\n  rowCount: PropTypes.number.isRequired,\n\n  /**\n   * Responsible for rendering a table row given an array of columns:\n   * Should implement the following interface: ({\n   *   className: string,\n   *   columns: Array,\n   *   index: number,\n   *   isScrolling: boolean,\n   *   onRowClick: ?Function,\n   *   onRowDoubleClick: ?Function,\n   *   onRowMouseOver: ?Function,\n   *   onRowMouseOut: ?Function,\n   *   rowData: any,\n   *   style: any\n   * }): PropTypes.node\n   */\n  rowRenderer: PropTypes.func,\n\n  /** Optional custom inline style to attach to table rows. */\n  rowStyle: PropTypes.oneOfType([PropTypes.object, PropTypes.func]).isRequired,\n\n  /** See Grid#scrollToAlignment */\n  scrollToAlignment: PropTypes.oneOf(['auto', 'end', 'start', 'center']).isRequired,\n\n  /** Row index to ensure visible (by forcefully scrolling if necessary) */\n  scrollToIndex: PropTypes.number.isRequired,\n\n  /** Vertical offset. */\n  scrollTop: PropTypes.number,\n\n  /**\n   * Sort function to be called if a sortable header is clicked.\n   * Should implement the following interface: ({\n   *   defaultSortDirection: 'ASC' | 'DESC',\n   *   event: MouseEvent,\n   *   sortBy: string,\n   *   sortDirection: SortDirection\n   * }): void\n   */\n  sort: PropTypes.func,\n\n  /** Table data is currently sorted by this :dataKey (if it is sorted at all) */\n  sortBy: PropTypes.string,\n\n  /** Table data is currently sorted in this direction (if it is sorted at all) */\n  sortDirection: PropTypes.oneOf([SortDirection.ASC, SortDirection.DESC]),\n\n  /** Optional inline style */\n  style: PropTypes.object,\n\n  /** Tab index for focus */\n  tabIndex: PropTypes.number,\n\n  /** Width of list */\n  width: PropTypes.number.isRequired\n} : {};\nimport { bpfrpt_proptype_CellPosition } from '../Grid';","import createMultiSort from './createMultiSort';\nimport defaultCellDataGetter from './defaultCellDataGetter';\nimport defaultCellRenderer from './defaultCellRenderer';\nimport defaultHeaderRowRenderer from './defaultHeaderRowRenderer.js';\nimport defaultHeaderRenderer from './defaultHeaderRenderer';\nimport defaultRowRenderer from './defaultRowRenderer';\nimport Column from './Column';\nimport SortDirection from './SortDirection';\nimport SortIndicator from './SortIndicator';\nimport Table from './Table';\nexport default Table;\nexport { createMultiSort, defaultCellDataGetter, defaultCellRenderer, defaultHeaderRowRenderer, defaultHeaderRenderer, defaultRowRenderer, Column, SortDirection, SortIndicator, Table };","import _extends from 'babel-runtime/helpers/extends';\nimport _Object$getPrototypeOf from 'babel-runtime/core-js/object/get-prototype-of';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\nimport * as React from 'react';\nimport createDetectElementResize from '../vendor/detectElementResize';\n\nvar AutoSizer = function (_React$PureComponent) {\n  _inherits(AutoSizer, _React$PureComponent);\n\n  function AutoSizer() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, AutoSizer);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = AutoSizer.__proto__ || _Object$getPrototypeOf(AutoSizer)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      height: _this.props.defaultHeight || 0,\n      width: _this.props.defaultWidth || 0\n    }, _this._onResize = function () {\n      var _this$props = _this.props,\n          disableHeight = _this$props.disableHeight,\n          disableWidth = _this$props.disableWidth,\n          onResize = _this$props.onResize;\n\n      if (_this._parentNode) {\n        // Guard against AutoSizer component being removed from the DOM immediately after being added.\n        // This can result in invalid style values which can result in NaN values if we don't handle them.\n        // See issue #150 for more context.\n        var _height = _this._parentNode.offsetHeight || 0;\n\n        var _width = _this._parentNode.offsetWidth || 0;\n\n        var _style = window.getComputedStyle(_this._parentNode) || {};\n\n        var paddingLeft = parseInt(_style.paddingLeft, 10) || 0;\n        var paddingRight = parseInt(_style.paddingRight, 10) || 0;\n        var paddingTop = parseInt(_style.paddingTop, 10) || 0;\n        var paddingBottom = parseInt(_style.paddingBottom, 10) || 0;\n        var newHeight = _height - paddingTop - paddingBottom;\n        var newWidth = _width - paddingLeft - paddingRight;\n\n        if (!disableHeight && _this.state.height !== newHeight || !disableWidth && _this.state.width !== newWidth) {\n          _this.setState({\n            height: _height - paddingTop - paddingBottom,\n            width: _width - paddingLeft - paddingRight\n          });\n\n          onResize({\n            height: _height,\n            width: _width\n          });\n        }\n      }\n    }, _this._setRef = function (autoSizer) {\n      _this._autoSizer = autoSizer;\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  _createClass(AutoSizer, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var nonce = this.props.nonce;\n\n      if (this._autoSizer && this._autoSizer.parentNode && this._autoSizer.parentNode.ownerDocument && this._autoSizer.parentNode.ownerDocument.defaultView && this._autoSizer.parentNode instanceof this._autoSizer.parentNode.ownerDocument.defaultView.HTMLElement) {\n        // Delay access of parentNode until mount.\n        // This handles edge-cases where the component has already been unmounted before its ref has been set,\n        // As well as libraries like react-lite which have a slightly different lifecycle.\n        this._parentNode = this._autoSizer.parentNode; // Defer requiring resize handler in order to support server-side rendering.\n        // See issue #41\n\n        this._detectElementResize = createDetectElementResize(nonce);\n\n        this._detectElementResize.addResizeListener(this._parentNode, this._onResize);\n\n        this._onResize();\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      if (this._detectElementResize && this._parentNode) {\n        this._detectElementResize.removeResizeListener(this._parentNode, this._onResize);\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          children = _props.children,\n          className = _props.className,\n          disableHeight = _props.disableHeight,\n          disableWidth = _props.disableWidth,\n          style = _props.style;\n      var _state = this.state,\n          height = _state.height,\n          width = _state.width; // Outer div should not force width/height since that may prevent containers from shrinking.\n      // Inner component should overflow and use calculated width/height.\n      // See issue #68 for more information.\n\n      var outerStyle = {\n        overflow: 'visible'\n      };\n      var childParams = {};\n\n      if (!disableHeight) {\n        outerStyle.height = 0;\n        childParams.height = height;\n      }\n\n      if (!disableWidth) {\n        outerStyle.width = 0;\n        childParams.width = width;\n      }\n      /**\n       * TODO: Avoid rendering children before the initial measurements have been collected.\n       * At best this would just be wasting cycles.\n       * Add this check into version 10 though as it could break too many ref callbacks in version 9.\n       * Note that if default width/height props were provided this would still work with SSR.\n      if (\n        height !== 0 &&\n        width !== 0\n      ) {\n        child = children({ height, width })\n      }\n      */\n\n\n      return React.createElement('div', {\n        className: className,\n        ref: this._setRef,\n        style: _extends({}, outerStyle, style)\n      }, children(childParams));\n    }\n  }]);\n\n  return AutoSizer;\n}(React.PureComponent);\n\nAutoSizer.defaultProps = {\n  onResize: function onResize() {},\n  disableHeight: false,\n  disableWidth: false,\n  style: {}\n};\nAutoSizer.propTypes = process.env.NODE_ENV === 'production' ? null : {\n  /** Function responsible for rendering children.*/\n  children: PropTypes.func.isRequired,\n\n  /** Optional custom CSS class name to attach to root AutoSizer element.  */\n  className: PropTypes.string,\n\n  /** Default height to use for initial render; useful for SSR */\n  defaultHeight: PropTypes.number,\n\n  /** Default width to use for initial render; useful for SSR */\n  defaultWidth: PropTypes.number,\n\n  /** Disable dynamic :height property */\n  disableHeight: PropTypes.bool.isRequired,\n\n  /** Disable dynamic :width property */\n  disableWidth: PropTypes.bool.isRequired,\n\n  /** Nonce of the inlined stylesheet for Content Security Policy */\n  nonce: PropTypes.string,\n\n  /** Callback to be invoked on-resize */\n  onResize: PropTypes.func.isRequired,\n\n  /** Optional inline style */\n  style: PropTypes.object\n};\nexport default AutoSizer;\nimport PropTypes from 'prop-types';","export { default } from './AutoSizer';\nexport { default as AutoSizer } from './AutoSizer';"],"sourceRoot":""}